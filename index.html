<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <title>Análise Técnica Crypto/USDT Futures - V2.2 DEFINITIVA</title>
    <style>
        :root {
            --bg-dark: #0b0e11; --bg-medium: #1e2329; --bg-light: #2b3139; --text-primary: #eaecef;
            --text-secondary: #848e9c; --accent: #f0b90b; --accent-hover: #f8d12f; --green: #02c076;
            --red: #f84960; --green-bg: rgba(2, 192, 118, 0.1); --red-bg: rgba(248, 73, 96, 0.1);
            --blue: #3861fb; --orange: #ff6b35;
        }
        * { box-sizing: border-box; }
        body { font-family: 'Noto Sans', 'Inter', Arial, sans-serif; line-height: 1.6; background-color: var(--bg-dark); color: var(--text-primary); margin: 0; padding: 0; font-size: 16px; }
        .container { display: flex; flex-direction: row; min-height: 100vh; }
        .main-content { 
            flex-grow: 1; 
            padding: 28px; 
            margin-left: 0;
            margin-right: 0;
            max-width: none;
            transition: margin-left 0.3s ease;
        }
        .main-content.with-sidebar {
            margin-left: 280px;
        }
        .sidebar { width: 280px; background-color: var(--bg-medium); border-right: 1px solid var(--bg-light); padding: 28px 20px; height: 100vh; position: fixed; left: 0; top: 0; overflow-y: auto; scrollbar-width: thin; scrollbar-color: var(--accent) var(--bg-light); box-shadow: 8px 0 24px rgba(0,0,0,0.35); z-index: 1002; }
        
        /* Header com novas funcionalidades */
        header { background-color: var(--bg-medium); padding: 20px 28px; border-radius: 10px; margin-bottom: 28px; box-shadow: 0 8px 24px rgba(0,0,0,0.25); }
        h1 { color: var(--accent); text-align: center; font-size: 32px; margin: 24px 0 12px 0; letter-spacing: 0.3px; }
        .version-badge { background: linear-gradient(135deg, var(--accent), var(--orange)); color: var(--bg-dark); padding: 6px 14px; border-radius: 12px; font-size: 12px; font-weight: bold; display: inline-block; margin-left: 10px; }
        p.subtitle { text-align: center; color: var(--text-secondary); margin-bottom: 24px; font-size: 15px; }
        
        /* Novo painel de controle */
        .control-panel { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px; }
        .control-group { background-color: var(--bg-light); padding: 12px 14px; border-radius: 8px; }
        .control-group label { display: block; font-size: 14px; color: var(--text-secondary); margin-bottom: 7px; font-weight: 600; }
        .control-group select, .control-group input { width: 100%; padding: 9px 11px; background-color: var(--bg-dark); color: var(--text-primary); border: 1px solid var(--bg-light); border-radius: 6px; font-size: 15px; }
        
        /* Toggle switches */
        .switch-container { display: flex; align-items: center; justify-content: space-between; margin: 8px 0; }
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--bg-dark); transition: .3s; border-radius: 24px; border: 1px solid var(--bg-light); }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: var(--text-secondary); transition: .3s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--green); border-color: var(--green); }
        input:checked + .slider:before { transform: translateX(20px); background-color: white; }
        
        /* Notificações melhoradas */
        .notification { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: linear-gradient(135deg, var(--bg-medium), var(--bg-light)); 
            color: var(--text-primary); 
            padding: 20px; 
            border-radius: 12px; 
            box-shadow: 0 12px 40px rgba(0,0,0,0.5); 
            z-index: 1000; 
            animation: slideIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55); 
            max-width: 350px;
            border: 2px solid;
        }
        .notification.success { 
            border-color: var(--green);
            box-shadow: 0 12px 40px rgba(2, 192, 118, 0.4);
        }
        .notification.danger { 
            border-color: var(--red);
            box-shadow: 0 12px 40px rgba(248, 73, 96, 0.4);
        }
        .notification.info {
            border-color: var(--accent);
            box-shadow: 0 12px 40px rgba(240, 185, 11, 0.3);
        }
        @keyframes slideIn { from { transform: translateX(400px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(400px); opacity: 0; } }
        .notification.hiding { animation: slideOut 0.3s ease-out; }
        
        /* Stats cards melhorados */
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 18px; margin-bottom: 28px; }
        .stat-card { background: linear-gradient(135deg, var(--bg-medium), var(--bg-light)); padding: 20px; border-radius: 10px; border-left: 4px solid var(--accent); box-shadow: 0 4px 16px rgba(0,0,0,0.2); transition: transform 0.2s; }
        .stat-card:hover { transform: translateY(-2px); }
        .stat-label { font-size: 13px; color: var(--text-secondary); margin-bottom: 8px; font-weight: 600; text-transform: uppercase; }
        .stat-value { font-size: 28px; font-weight: bold; color: var(--accent); }
        .stat-trend { font-size: 13px; margin-top: 8px; }
        .trend-up { color: var(--green); }
        .trend-down { color: var(--red); }
        
        /* Price info melhorado */
        .price-info { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 28px; padding: 28px; background: linear-gradient(135deg, var(--bg-medium), var(--bg-light)); border-radius: 10px; margin-bottom: 28px; border-left: 4px solid var(--accent); box-shadow: 0 6px 20px rgba(0,0,0,0.25); }
        .price-main { display: flex; flex-direction: column; gap: 12px; }
        .current-price { font-size: 36px; font-weight: bold; color: var(--accent); }
        .price-change { font-size: 20px; font-weight: 600; }
        
        /* Indicators grid melhorado */
        .indicators-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 24px; margin-top: 28px; }
        .indicator-card { background: linear-gradient(135deg, var(--bg-medium), var(--bg-light)); border-radius: 12px; padding: 22px; border-left: 4px solid var(--accent); box-shadow: 0 6px 20px rgba(0,0,0,0.22); transition: all 0.3s; position: relative; display: flex; flex-direction: column; }
        .indicator-card::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, transparent, rgba(240, 185, 11, 0.05)); pointer-events: none; z-index: 0; }
        .indicator-card:hover { transform: translateY(-4px); box-shadow: 0 12px 32px rgba(0,0,0,0.3); }
        .indicator-card.bullish { border-left-color: var(--green); }
        .indicator-card.bearish { border-left-color: var(--red); }
        .indicator-card > * { position: relative; z-index: 1; }
        
        /* Timeframe header melhorado */
        .timeframe-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--bg-light); }
        .timeframe-title { font-size: 20px; font-weight: bold; color: var(--accent); }
        .signal-badge { padding: 6px 14px; border-radius: 6px; font-size: 13px; font-weight: bold; text-transform: uppercase; }
        .signal-badge.buy { background-color: var(--green-bg); color: var(--green); border: 1px solid var(--green); }
        .signal-badge.sell { background-color: var(--red-bg); color: var(--red); border: 1px solid var(--red); }
        .signal-badge.neutral { background-color: rgba(132, 142, 156, 0.1); color: var(--text-secondary); border: 1px solid var(--text-secondary); }
        
        /* Confidence meter melhorado */
        .confidence-meter-container { margin: 18px 0; }
        .confidence-label { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 13px; color: var(--text-secondary); }
        .confidence-meter { width: 100%; height: 16px; background: linear-gradient(to right, var(--red), var(--accent), var(--green)); border-radius: 8px; overflow: hidden; position: relative; box-shadow: inset 0 2px 4px rgba(0,0,0,0.3); }
        .confidence-indicator { position: absolute; width: 4px; height: 100%; background-color: white; box-shadow: 0 0 8px rgba(255,255,255,0.8); transition: left 0.5s ease; }
        
        /* Indicator strength melhorado */
        .indicator-strength-list { margin-top: 16px; display: flex; flex-direction: column; gap: 12px; }
        .indicator-strength-item { display: flex; align-items: center; gap: 12px; }
        .indicator-label { width: 130px; font-size: 13px; color: var(--text-secondary); font-weight: 600; }
        .indicator-bar-container { flex-grow: 1; height: 14px; background-color: var(--bg-dark); border-radius: 7px; border: 1px solid var(--bg-light); overflow: hidden; position: relative; }
        .indicator-bar-fill { height: 100%; transition: width 0.5s ease, background-color 0.3s; }
        .indicator-percent { width: 55px; text-align: right; font-weight: bold; font-size: 13px; }
        
        /* Trade suggestions melhorado */
        .trade-suggestions { margin-top: 18px; padding: 16px; background-color: var(--bg-dark); border-radius: 8px; border: 1px solid var(--bg-light); }
        .trade-row { display: flex; justify-content: space-between; padding: 8px 0; font-size: 14px; border-bottom: 1px solid var(--bg-light); }
        .trade-row:last-child { border-bottom: none; }
        .trade-label { color: var(--text-secondary); }
        .trade-value { font-weight: bold; }
        
        /* History section melhorado */
        .history-section { margin-top: 18px; border-top: 1px solid var(--bg-light); padding-top: 18px; }
        .history-stats { display: flex; justify-content: space-around; font-size: 13px; color: var(--text-secondary); margin-bottom: 16px; }
        .history-stat { text-align: center; }
        .history-stat-value { font-size: 18px; font-weight: bold; color: var(--accent); display: block; margin-top: 6px; }
        
        /* Scroll personalizado para histórico */
        .history-section > div[id^="history-"]::-webkit-scrollbar {
            width: 8px;
        }
        .history-section > div[id^="history-"]::-webkit-scrollbar-track {
            background: var(--bg-dark);
            border-radius: 4px;
        }
        .history-section > div[id^="history-"]::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 4px;
        }
        .history-section > div[id^="history-"]::-webkit-scrollbar-thumb:hover {
            background: var(--accent-hover);
        }
        
        /* Buttons melhorados */
        .button-group { display: flex; gap: 10px; margin-top: auto; padding-top: 14px; border-top: 1px solid var(--bg-dark); flex-wrap: wrap; }
        .btn { flex: 1; padding: 10px 12px; border-radius: 8px; border: none; font-size: 12px; font-weight: 600; cursor: pointer; transition: all 0.2s; text-align: center; min-width: 80px; }
        .btn-primary { background: linear-gradient(135deg, var(--accent), var(--accent-hover)); color: var(--bg-dark); }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(240, 185, 11, 0.4); }
        .btn-secondary { background-color: var(--bg-light); color: var(--text-primary); border: 1px solid var(--bg-light); font-size: 11px; }
        .btn-secondary:hover { background-color: var(--bg-medium); }
        .btn-danger { background-color: rgba(248, 73, 96, 0.2); color: var(--red); border: 1px solid var(--red); font-size: 11px; }
        .btn-danger:hover { background-color: var(--red); color: var(--text-primary); }
        
        /* Charts container melhorado */
        .charts-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 24px; margin-top: 36px; }
        .window { background-color: var(--bg-medium); border-radius: 12px; overflow: hidden; height: 500px; box-shadow: 0 8px 24px rgba(0,0,0,0.25); transition: transform 0.3s; }
        .window:hover { transform: translateY(-4px); }
        .window-header { padding: 16px; font-weight: bold; color: var(--text-primary); background: linear-gradient(135deg, var(--bg-light), var(--bg-medium)); display: flex; justify-content: space-between; align-items: center; }
        .window-content { height: calc(100% - 52px); }
        .window-content iframe { width: 100%; height: 100%; border: none; }
        
        /* Whale tracking melhorado */
        .whale-orders-title { color: var(--accent); font-size: 20px; margin-bottom: 18px; padding-bottom: 12px; border-bottom: 2px solid var(--accent); text-align: center; font-weight: bold; }
        .whale-summary { padding: 16px; margin-bottom: 18px; background: linear-gradient(135deg, var(--bg-light), var(--bg-medium)); border-radius: 8px; font-size: 15px; }
        .whale-pressure-bar { width: 100%; height: 12px; background-color: var(--red); border-radius: 6px; overflow: hidden; margin-top: 10px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.3); }
        .whale-pressure-fill { height: 100%; background-color: var(--green); transition: width 0.5s ease; }
        .whale-order { padding: 14px; margin: 10px 0; border-radius: 8px; font-size: 14px; border-left: 4px solid; transition: all 0.3s; }
        .whale-order:hover { transform: translateX(-4px); }
        .whale-buy { background-color: var(--green-bg); border-left-color: var(--green); }
        .whale-sell { background-color: var(--red-bg); border-left-color: var(--red); }
        
        /* Loading state melhorado */
        .loading { text-align: center; padding: 60px 20px; }
        .loading-spinner { width: 50px; height: 50px; border: 4px solid var(--bg-light); border-top: 4px solid var(--accent); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* Status indicators melhorados */
        .status-panel { font-size: 12px; color: var(--text-secondary); text-align: center; padding: 16px; border-top: 1px solid var(--bg-light); margin-top: 28px; }
        .status-item { display: flex; align-items: center; justify-content: center; margin: 8px 0; }
        .status-dot { height: 12px; width: 12px; background-color: var(--red); border-radius: 50%; display: inline-block; margin-right: 10px; transition: background-color 0.5s; animation: pulse 2s infinite; }
        .status-dot.connected { background-color: var(--green); animation: none; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        /* Performance metrics */
        .performance-chart { background-color: var(--bg-light); border-radius: 8px; padding: 18px; margin-top: 18px; }
        .metric-row { display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid var(--bg-dark); font-size: 13px; }
        .metric-row:last-child { border-bottom: none; }
        
        /* Slider personalizado */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: linear-gradient(to right, var(--bg-dark), var(--accent));
            border-radius: 3px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(240, 185, 11, 0.6);
            transition: all 0.2s;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 12px rgba(240, 185, 11, 0.8);
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(240, 185, 11, 0.6);
            transition: all 0.2s;
        }
        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 12px rgba(240, 185, 11, 0.8);
        }
        
        /* Responsividade */
        @media (max-width: 1200px) {
            .main-content { max-width: 100%; }
            .sidebar { position: relative; width: 100%; height: auto; border-left: none; border-top: 1px solid var(--bg-light); }
            .container { flex-direction: column; }
        }
        
        @media (max-width: 768px) {
            .indicators-grid { grid-template-columns: 1fr; }
            .charts-container { grid-template-columns: 1fr; }
            .stats-grid { grid-template-columns: 1fr; }
            h1 { font-size: 22px; }
            .current-price { font-size: 24px; }
        }
    
        /* ===== SIDEBAR COLAPSÁVEL ===== */
        .sidebar {
            transition: left 0.3s ease, opacity 0.3s ease;
        }
        .sidebar.collapsed {
            left: -280px;
            opacity: 0;
            pointer-events: none;
        }
        .sidebar-toggle {
            position: fixed;
            left: 0;
            top: 60%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, var(--accent), var(--orange));
            color: var(--bg-dark);
            border: none;
            border-radius: 0 8px 8px 0;
            padding: 20px 12px;
            cursor: pointer;
            font-size: 20px;
            z-index: 1001;
            box-shadow: 4px 0 12px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            writing-mode: vertical-rl;
            font-weight: bold;
        }
        .sidebar-toggle.collapsed {
            left: 0;
        }
        .sidebar-toggle:not(.collapsed) {
            left: 280px;
        }
        .sidebar-toggle:hover {
            padding-left: 18px;
            box-shadow: 4px 0 20px rgba(240, 185, 11, 0.5);
        }

        /* Sidebar de Sinais (esquerda) */
        .sidebar-signals {
            width: 280px;
            background-color: var(--bg-medium);
            border-right: 1px solid var(--bg-light);
            padding: 28px 20px;
            height: 100vh;
            position: fixed;
            left: 0;
            top: 0;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--accent) var(--bg-light);
            box-shadow: 8px 0 24px rgba(0,0,0,0.35);
            z-index: 1002;
            transition: left 0.3s ease, opacity 0.3s ease;
        }
        .sidebar-signals.collapsed {
            left: -280px;
            opacity: 0;
            pointer-events: none;
        }
        .sidebar-signals-toggle {
            position: fixed;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, var(--green), #00a884);
            color: white;
            border: none;
            border-radius: 0 8px 8px 0;
            padding: 20px 12px;
            cursor: pointer;
            font-size: 20px;
            z-index: 1001;
            box-shadow: 4px 0 12px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            writing-mode: vertical-rl;
            font-weight: bold;
        }
        .sidebar-signals-toggle.collapsed {
            left: 0;
        }
        .sidebar-signals-toggle:not(.collapsed) {
            left: 280px;
        }
        .sidebar-signals-toggle:hover {
            padding-left: 18px;
            box-shadow: 4px 0 20px rgba(2, 192, 118, 0.5);
        }
        
        /* Responsividade */
        @media (max-width: 1400px) {
            .main-content {
                margin-right: 0;
                max-width: calc(100% - 380px);
            }
            .main-content.with-signals-sidebar {
                margin-left: 280px;
                max-width: calc(100% - 660px);
            }
            .sidebar { position: relative; width: 100%; height: auto; border-left: none; border-top: 1px solid var(--bg-light); }
        }
        
        @media (max-width: 768px) {
            .main-content {
                margin-left: 0;
                margin-right: 0;
                max-width: 100%;
            }
            .sidebar-signals, .sidebar { 
                position: relative; 
                width: 100%; 
                height: auto; 
            }
        }

        /* ===== MODAL DE BACKTESTING ===== */
        .backtest-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.85);
            overflow-y: auto;
            animation: fadeIn 0.3s;
            backdrop-filter: blur(5px);
        }
        .backtest-content {
            background: linear-gradient(135deg, var(--bg-medium), var(--bg-dark));
            margin: 2% auto;
            padding: 35px;
            border: 3px solid var(--accent);
            border-radius: 20px;
            width: 95%;
            max-width: 1400px;
            box-shadow: 0 25px 80px rgba(0,0,0,0.7);
            animation: slideDown 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        @keyframes slideDown {
            from { transform: translateY(-100px) scale(0.9); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }
        .backtest-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid var(--accent);
        }
        .backtest-title {
            font-size: 28px;
            font-weight: bold;
            background: linear-gradient(135deg, var(--accent), var(--orange));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .backtest-close {
            font-size: 36px;
            font-weight: bold;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        .backtest-close:hover {
            color: var(--red);
            background-color: rgba(248, 73, 96, 0.1);
            transform: rotate(90deg);
        }
        .backtest-config {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 25px;
            background: linear-gradient(135deg, rgba(240, 185, 11, 0.05), rgba(255, 107, 53, 0.05));
            border-radius: 12px;
        }
        .backtest-config-item label {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 10px;
            font-weight: 700;
            text-transform: uppercase;
        }
        .backtest-config-item select,
        .backtest-config-item input {
            padding: 12px 15px;
            background: linear-gradient(135deg, var(--bg-dark), var(--bg-medium));
            color: var(--text-primary);
            border: 2px solid var(--bg-light);
            border-radius: 8px;
            font-size: 15px;
        }
        .backtest-btn {
            padding: 16px 24px;
            border-radius: 10px;
            border: none;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        .backtest-btn-run {
            background: linear-gradient(135deg, var(--green), #00e676);
            color: white;
        }
        .backtest-btn-run:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(2, 192, 118, 0.5);
        }
        .backtest-results { display: none; }
        .backtest-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .backtest-stat-card {
            background: linear-gradient(135deg, var(--bg-dark), var(--bg-medium));
            padding: 20px;
            border-radius: 12px;
            border-left: 5px solid var(--accent);
            text-align: center;
        }
        .backtest-stat-value {
            font-size: 32px;
            font-weight: bold;
            color: var(--accent);
        }
        .backtest-stat-value.positive { color: var(--green); }
        .backtest-stat-value.negative { color: var(--red); }
        .backtest-chart-container {
            background: linear-gradient(135deg, var(--bg-dark), var(--bg-medium));
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 30px;
        }
        .backtest-loading { text-align: center; padding: 60px; }
    
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <h1>
                🚀 Análise Técnica: <span id="symbol-display-header" style="color: var(--accent);">BTC/USDT</span> Futures
                <span class="version-badge">V2.2 DEFINITIVA</span>
            </h1>
            <p class="subtitle">Recomendações de trading baseadas em múltiplos indicadores técnicos • Análise em tempo real • Gestão de risco automática</p>
            
            <!-- Painel de Controle -->
            <header>
                <div class="control-panel">
                    <!-- Coluna Esquerda: Controles Básicos + Switches -->
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <!-- Painel Compacto: Cripto, Alavancagem e Intervalo -->
                        <div class="control-group">
                            <div style="display: grid; grid-template-columns: 2fr 1fr 1fr; gap: 12px; align-items: end;">
                                <div>
                                    <label>📊 Criptomoeda</label>
                                    <select id="cryptoSelect" onchange="changeCrypto(this.value)">
                                        <option value="BTCUSDT">BTC/USDT</option>
                                        <option value="ETHUSDT">ETH/USDT</option>
                                        <option value="BNBUSDT">BNB/USDT</option>
                                        <option value="DOGEUSDT">DOGE/USDT</option>
                                        <option value="ADAUSDT">ADA/USDT</option>
                                        <option value="XRPUSDT">XRP/USDT</option>
                                        <option value="SOLUSDT">SOL/USDT</option>
                                        <option value="DOTUSDT">DOT/USDT</option>
                                    </select>
                                </div>
                                <div>
                                    <label>⚡ Alavancagem</label>
                                    <select id="leverageSelect" onchange="updateLeverage()">
                                        <option value="1">1x</option>
                                        <option value="5">5x</option>
                                        <option value="10">10x</option>
                                        <option value="20">20x</option>
                                        <option value="50">50x</option>
                                        <option value="100">100x</option>
                                    </select>
                                </div>
                                <div>
                                    <label>⏱️ Intervalo</label>
                                    <select id="refreshInterval" onchange="updateRefreshInterval()">
                                        <option value="3000">3s</option>
                                        <option value="5000" selected>5s</option>
                                        <option value="10000">10s</option>
                                        <option value="30000">30s</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Switches Compactos -->
                        <div class="control-group">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px 14px;">
                                <div class="switch-container" style="margin: 0;">
                                    <label style="margin: 0; font-size: 13px; font-weight: 500;">🔔 Notificações</label>
                                    <label class="switch" style="width: 40px; height: 22px;">
                                        <input type="checkbox" id="soundNotifications" checked>
                                        <span class="slider"></span>
                                    </label>
                                </div>
                                <div class="switch-container" style="margin: 0;">
                                    <label style="margin: 0; font-size: 13px; font-weight: 500;">📢 Alertas</label>
                                    <label class="switch" style="width: 40px; height: 22px;">
                                        <input type="checkbox" id="visualNotifications" checked>
                                        <span class="slider"></span>
                                    </label>
                                </div>
                                <div class="switch-container" style="margin: 0;">
                                    <label style="margin: 0; font-size: 13px; font-weight: 500;">🎨 Tendência</label>
                                    <label class="switch" style="width: 40px; height: 22px;">
                                        <input type="checkbox" id="trendFilter" checked>
                                        <span class="slider"></span>
                                    </label>
                                </div>
                                <div class="switch-container" style="margin: 0;">
                                    <label style="margin: 0; font-size: 13px; font-weight: 500;">📊 Divergências</label>
                                    <label class="switch" style="width: 40px; height: 22px;">
                                        <input type="checkbox" id="divergenceDetection" checked>
                                        <span class="slider"></span>
                                    </label>
                                </div>
                                <div class="switch-container" style="margin: 0;">
                                    <label style="margin: 0; font-size: 13px; font-weight: 500;">🐋 Baleias</label>
                                    <label class="switch" style="width: 40px; height: 22px;">
                                        <input type="checkbox" id="whaleTracking" checked>
                                        <span class="slider"></span>
                                    </label>
                                </div>
                                <div class="switch-container" style="margin: 0;">
                                    <label style="margin: 0; font-size: 13px; font-weight: 500;">💾 Backup</label>
                                    <label class="switch" style="width: 40px; height: 22px;">
                                        <input type="checkbox" id="autoBackup" checked>
                                        <span class="slider"></span>
                                    </label>
                                </div>
                            </div>
                            <div style="text-align: center; margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--bg-dark);">
                                <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 3px; font-weight: 500;">⏰ Horário Brasília</div>
                                <div id="current-time" style="font-size: 17px; font-weight: bold; color: var(--accent); letter-spacing: 0.5px;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>🎯 Modo de Trading & Score Mínimo</label>
                        <div style="margin-bottom: 8px;">
                            <div id="tradingMode" style="
                                padding: 9px 11px;
                                background-color: var(--bg-dark);
                                color: var(--text-primary);
                                border: 1px solid var(--bg-light);
                                border-radius: 6px;
                                font-size: 15px;
                                font-weight: 600;
                                text-align: center;
                            " data-mode="balanced">⚖️ Balanceado</div>
                            <select id="tradingModeHidden" style="display: none;">
                                <option value="aggressive">⚡ Agressivo (+ sinais)</option>
                                <option value="balanced" selected>⚖️ Balanceado</option>
                                <option value="conservative">🛡️ Conservador (- sinais)</option>
                                <option value="perfect">🌟 Perfect (sinais perfeitos)</option>
                            </select>
                        </div>
                        
                        <!-- Score Slider com indicadores -->
                        <div style="margin-top: 8px;">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px;">
                                <span style="font-size: 11px; color: var(--text-secondary); font-weight: 600;">Score Mínimo:</span>
                                <input 
                                    type="number"
                                    id="minSignalStrength"
                                    value="50"
                                    min="0"
                                    step="1"
                                    style="
                                        font-weight: bold; 
                                        font-size: 16px;
                                        width: 80px;
                                        text-align: center;
                                        padding: 4px 8px;
                                        background: linear-gradient(135deg, var(--bg-dark), var(--bg-medium));
                                        border-radius: 5px;
                                        border: 2px solid var(--accent);
                                        color: var(--accent);
                                    "
                                    oninput="updateMinSignalStrength(this.value)"
                                />
                            </div>
                            
                            <div style="position: relative; margin-top: 8px;">
                                <!-- Indicadores de faixa -->
                                <div style="display: flex; justify-content: space-between; font-size: 10px; color: var(--text-secondary);">
                                    <span style="color: var(--red); font-weight: 600;">⚡ 0-39: Agressivo</span>
                                    <span style="color: var(--accent); font-weight: 600;">⚖️ 40-74: Balanceado</span>
                                    <span style="color: var(--green); font-weight: 600;">🛡️ 75-114: Conservador</span>
                                    <span style="color: var(--blue); font-weight: 600;">🌟 115+: Perfect</span>
                                    <span style="color: var(--text-primary); font-weight: 600;">150</span>
                                </div>
                            </div>
                        </div>
                        <div id="trading-mode-description" style="
                            margin-top: 10px;
                            padding: 10px 12px;
                            background: linear-gradient(135deg, var(--bg-dark), var(--bg-medium));
                            border-left: 3px solid var(--accent);
                            border-radius: 6px;
                            font-size: 11px;
                            line-height: 1.5;
                            color: var(--text-secondary);
                            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
                        "></div>
                        <div id="score-warning" style="
                            margin-top: 8px;
                            padding: 8px 10px;
                            background: linear-gradient(135deg, rgba(2, 192, 118, 0.1), rgba(2, 192, 118, 0.05));
                            border-left: 3px solid var(--green);
                            border-radius: 6px;
                            font-size: 10px;
                            color: var(--text-primary);
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            box-shadow: 0 2px 4px rgba(2, 192, 118, 0.15);
                        ">
                            <span style="font-size: 13px;">💡</span>
                            <span>Sinais com score abaixo de <span id="min-signal-inline" style="color: var(--green); font-weight: bold; font-size: 11px;">50</span> serão ignorados</span>
                        </div>
                    </div>
                </div>
            </header>
                    
                    <!-- Coluna Direita: Trading & Score -->
                    <div class="control-group">
            
            <!-- Stats Cards -->
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">📈 Win Rate Geral</div>
                    <div class="stat-value" id="overall-winrate">0%</div>
                    <div class="stat-trend trend-up" id="winrate-trend">+0% vs ontem</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-label">💰 Retorno Acumulado</div>
                    <div class="stat-value" id="overall-returns">0.00%</div>
                    <div class="stat-trend" id="returns-trend">Sem alavancagem</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-label">🎯 Sinais Hoje</div>
                    <div class="stat-value" id="signals-today">0</div>
                    <div class="stat-trend" id="signals-trend">0 confirmados</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-label">⚡ Melhor Timeframe</div>
                    <div class="stat-value" id="best-timeframe">-</div>
                    <div class="stat-trend" id="best-tf-accuracy">0% acurácia</div>
                </div>
                
                <div class="stat-card" style="background: linear-gradient(135deg, var(--accent), var(--orange));">
                    <div class="stat-label" style="color: white;">🧠 Sistema Adaptativo</div>
                    <div class="stat-value" id="adaptive-status" style="color: white; font-size: 14px;">ATIVO</div>
                    <div class="stat-trend" id="adaptive-info" style="color: rgba(255,255,255,0.9);">Aprendendo...</div>
                </div>
            </div>
            
            <!-- Price Info -->
            <!-- SEÇÃO DE PREÇO E SINAL REDESENHADA -->
            <div class="price-info">
                <!-- Coluna Esquerda: Preço -->
                <div style="flex: 1;">
                    <div style="display: flex; align-items: baseline; gap: 15px; margin-bottom: 15px;">
                        <div class="current-price" id="current-price">$0.00</div>
                        <div class="price-change" id="price-change">+0.00%</div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; font-size: 11px;">
                        <div>
                            <div style="color: var(--text-secondary);">Volume 24h</div>
                            <div style="font-weight: bold; color: var(--accent);" id="volume-24h">-</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary);">Máx 24h</div>
                            <div style="font-weight: bold; color: var(--green);" id="high-24h">-</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary);">Mín 24h</div>
                            <div style="font-weight: bold; color: var(--red);" id="low-24h">-</div>
                        </div>
                    </div>
                </div>
                
                <!-- Divisor Vertical -->
                <div style="width: 1px; background: var(--bg-light); margin: 0 20px;"></div>
                
                <!-- Coluna Direita: Recomendação de Trading -->
                <div style="flex: 1;">
                    <div style="text-align: center; margin-bottom: 10px;">
                        <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">
                            🎯 Recomendação de Trading
                        </div>
                        <div id="current-signal" class="signal-badge neutral" style="font-size: 18px; padding: 10px 24px;">
                            NEUTRO
                        </div>
                    </div>
                    
                    <!-- Barra de Confiança Simplificada -->
                    <div style="margin-top: 15px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 11px;">
                            <span style="color: var(--red);">📉 Venda</span>
                            <span style="color: var(--text-secondary);">Direção do Sinal</span>
                            <span style="color: var(--green);">📈 Compra</span>
                        </div>
                        <div class="confidence-meter">
                            <div class="confidence-indicator" id="confidence-indicator"></div>
                        </div>
                        <div style="text-align: center; margin-top: 6px;">
                            <span style="font-size: 14px; font-weight: bold; color: var(--accent);" id="confidence-percent">50%</span>
                            <span style="font-size: 10px; color: var(--text-secondary); margin-left: 8px;">
                                | Medo & Ganância: <span id="fng-value" style="font-weight: bold;">50</span>
                            </span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Info Rápida -->
            <div style="text-align: center; margin: 15px 0; padding: 12px; background: linear-gradient(135deg, var(--bg-medium), var(--bg-light)); border-radius: 8px; font-size: 12px;">
                <span style="color: var(--text-secondary);">💡 Dica: </span>
                <span style="color: var(--text-primary);">
                    A <strong style="color: var(--accent);">Direção do Sinal</strong> mostra o consenso dos indicadores. 
                    <strong style="color: var(--green);">&gt;60% = Compra forte</strong> | 
                    <strong style="color: var(--red);">&lt;40% = Venda forte</strong>
                </span>
                <span style="margin-left: 15px;">⏱️ Próxima atualização: <span id="countdown-timer-inline" style="color: var(--accent); font-weight: bold;">5s</span></span>
            </div>
            
            <!-- Botões de Controle Adaptativo -->
            <div style="display: flex; justify-content: center; gap: 10px; margin: 15px 0;">
                <button onclick="forceAdaptiveCheck()" style="
                    padding: 8px 16px;
                    font-size: 12px;
                    background: var(--accent);
                    color: white;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: bold;
                    transition: all 0.3s;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    🧠 Verificar Adaptativo
                </button>
                <button onclick="resetAdaptiveSystem()" style="
                    padding: 8px 16px;
                    font-size: 12px;
                    background: var(--red);
                    color: white;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: bold;
                    transition: all 0.3s;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    🔄 Resetar Adaptativos
                </button>
            </div>
            
            <!-- Indicators Grid -->
            <div id="result">
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <div style="font-size: 16px; color: var(--text-secondary);">Inicializando sistema de análise...</div>
                </div>
            </div>
            
            <!-- Charts -->
            <div class="charts-container">
                <div class="window">
                    <div class="window-header">
                        <span id="chart-title-1m">BTC (1m)</span>
                        <span style="font-size: 11px; color: var(--text-secondary);">TradingView</span>
                    </div>
                    <div class="window-content"><iframe data-timeframe="1m" src=""></iframe></div>
                </div>
                <div class="window">
                    <div class="window-header">
                        <span id="chart-title-5m">BTC (5m)</span>
                        <span style="font-size: 11px; color: var(--text-secondary);">TradingView</span>
                    </div>
                    <div class="window-content"><iframe data-timeframe="5m" src=""></iframe></div>
                </div>
                <div class="window">
                    <div class="window-header">
                        <span id="chart-title-15m">BTC (15m)</span>
                        <span style="font-size: 11px; color: var(--text-secondary);">TradingView</span>
                    </div>
                    <div class="window-content"><iframe data-timeframe="15m" src=""></iframe></div>
                </div>
                <div class="window">
                    <div class="window-header">
                        <span id="chart-title-1h">BTC (1h)</span>
                        <span style="font-size: 11px; color: var(--text-secondary);">TradingView</span>
                    </div>
                    <div class="window-content"><iframe data-timeframe="1h" src=""></iframe></div>
                </div>
            </div>

            <!-- SystemState Debug -->
            <div style="margin-top: 40px; padding: 16px; background: #0a0e12; border: 1px solid #1a1e24; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 11px;">
                <div style="color: #666; margin-bottom: 8px; font-size: 10px;">SystemState Monitor (debug)</div>
                <pre id="systemstate-debug" style="margin: 0; color: #888; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">Aguardando dados...</pre>
            </div>
        </div>
        
        <!-- Sidebar de Sinais (Esquerda) -->
        <button class="sidebar-signals-toggle collapsed" id="sidebar-signals-toggle" onclick="toggleSignalsSidebar()">
            🎯
        </button>
        
        <div class="sidebar-signals collapsed" id="sidebar-signals">
            <h2 style="color: var(--accent); font-size: 18px; margin: 0 0 20px 0; padding-bottom: 12px; border-bottom: 2px solid var(--accent);">
                🎯 Sinais de Hoje
            </h2>
            
            <div style="display: flex; justify-content: center; align-items: center; margin-bottom: 20px; padding: 16px; background: var(--bg-light); border-radius: 8px;">
                <div style="text-align: center;">
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 6px;">Total de Sinais</div>
                    <div id="signals-count-sidebar" style="font-size: 32px; font-weight: bold; color: var(--accent);">0</div>
                    <div id="signals-confirmed-sidebar" style="font-size: 10px; color: var(--green); margin-top: 4px;">0 confirmados</div>
                </div>
            </div>
            
            <div id="signals-list" style="max-height: calc(100vh - 250px); overflow-y: auto; font-size: 11px;">
                <div style="color: var(--text-secondary); text-align: center; padding: 40px 20px;">
                    Nenhum sinal registrado hoje...
                </div>
            </div>
        </div>
        
        <!-- Sidebar de Baleias (Esquerda) -->
        <!-- Sidebar -->
        <!-- Toggle da Sidebar -->
    <button class="sidebar-toggle collapsed" id="sidebar-toggle" onclick="toggleSidebar()">
        🐋
    </button>
    
    <div class="sidebar collapsed" id="sidebar">
            <h2 class="whale-orders-title">🐋 Ordens de Baleias</h2>
            
            <!-- Controle de Filtro -->
            <div style="margin-bottom: 15px; padding: 12px; background-color: var(--bg-light); border-radius: 8px;">
                <label style="display: block; font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; font-weight: 600;">
                    💰 Valor Mínimo da Ordem
                </label>
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                    <input 
                        type="range" 
                        id="whaleMinValue" 
                        min="0" 
                        max="10000000000" 
                        step="50000000" 
                        value="500000000"
                        style="flex: 1; cursor: pointer;"
                        onchange="updateWhaleFilter(this.value); updateWhaleDisplay(this.value)"
                        oninput="updateWhaleDisplay(this.value)"
                    >
                </div>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input 
                        type="text" 
                        id="whale-min-input"
                        value="500M"
                        placeholder="Ex: 5B, 500M, 10K"
                        style="
                            flex: 1;
                            padding: 10px 12px;
                            background-color: var(--bg-dark);
                            color: var(--accent);
                            border: 2px solid var(--accent);
                            border-radius: 6px;
                            font-weight: bold;
                            font-size: 14px;
                            text-align: center;
                            letter-spacing: 1px;
                        "
                        onchange="updateWhaleFilterFromInput(this.value)"
                        onkeypress="if(event.key === 'Enter') updateWhaleFilterFromInput(this.value)"
                    >
                </div>
                <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 10px; color: var(--text-secondary);">
                    <span>$100K</span>
                    <span>$500M</span>
                    <span>$10B</span>
                </div>
            </div>
            
            <div id="whale-summary" class="whale-summary">
                <div style="display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 8px;">
                    <span style="color: var(--green);">Compra: <strong id="whale-buy-total">0</strong></span>
                    <span style="color: var(--red);">Venda: <strong id="whale-sell-total">0</strong></span>
                </div>
                <div class="whale-pressure-bar">
                    <div class="whale-pressure-fill" id="whale-pressure-fill" style="width: 50%;"></div>
                </div>
                <div style="text-align: center; font-size: 11px; color: var(--text-secondary); margin-top: 6px;">
                    Pressão: <span id="whale-pressure-text">50% Compra</span>
                </div>
            </div>
            <div id="whale-orders" style="max-height: 500px; overflow-y: auto;"></div>
            
            <!-- Status Panel -->
            <div class="status-panel">
                <div style="font-weight: bold; margin-bottom: 10px; color: var(--accent);">Status das Conexões</div>
                <div class="status-item">
                    <span class="status-dot" id="status-dot-analysis"></span>
                    <span>Sistema de Análise</span>
                </div>
                <div class="status-item">
                    <span class="status-dot" id="status-dot-price"></span>
                    <span>Feed de Preços</span>
                </div>
                <div class="status-item">
                    <span class="status-dot" id="status-dot-whale"></span>
                    <span>Rastreio de Baleias</span>
                </div>
                <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid var(--bg-light); font-size: 9px;">
                    Última atualização: <span id="last-update">-</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Notification Container -->
    <div id="notification-container"></div>
    
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="engine.js"></script>
    <script src="evaluation.js"></script>
    <script src="performanceAnalysis.js"></script>
    <script src="strategyInsights.js"></script>
    <script>
        // ============================================
        // VARIÁVEIS GLOBAIS E CONFIGURAÇÃO
        // ============================================
        let config = {
            symbol: 'BTCUSDT',
            leverage: 1,
            refreshInterval: 5000,
            tradingMode: 'balanced',
            minSignalStrength: 50, // Força mínima do sinal (score total)
            soundNotifications: true,
            visualNotifications: true,
            trendFilter: false, // Desabilitado temporariamente para debug
            divergenceDetection: true,
            whaleTracking: true,
            autoBackup: true,
            whaleMinValue: 500000 // Valor mínimo para ordem de baleia ($500k)
        };
        
        let state = {
            tradeHistory: {
                '1m': [],
                '5m': [],
                '15m': [],
                '1h': []
            },
            sessionStats: { signalsToday: 0, confirmedSignals: 0 },
            lastAnalysisTime: 0,
            isAnalyzing: false, // Flag para prevenir análises simultâneas
            ws: null,
            wsPrice: null,
            wsOrderbook: null,
            whaleSummary: { buy: 0, sell: 0, buyPressure: 0.5 },
            currentPrice: 0,
            priceChangePercent: 0,
            lastNotification: 0,
            indicatorCache: {},
            performanceMetrics: {},
            priceTracker: {}, // CORREÇÃO #2: Rastrear high/low dos trades
            
            // 🧠 SISTEMA ADAPTATIVO (MACHINE LEARNING)
            adaptiveSystem: {
                '1m': {
                    threshold: 10, // Começa com 10%
                    indicatorWeights: { rsi: 1, macd: 1, stochRsi: 1, mfi: 1, trend: 1, occ: 1, stcCci: 1 },
                    lastAdjustment: Date.now(),
                    mode: 'normal', // normal, conservative, aggressive, inverse
                    performanceWindow: [] // Últimos 10 trades
                },
                '5m': {
                    threshold: 10,
                    indicatorWeights: { rsi: 1, macd: 1, stochRsi: 1, mfi: 1, trend: 1, occ: 1, stcCci: 1 },
                    lastAdjustment: Date.now(),
                    mode: 'normal',
                    performanceWindow: []
                },
                '15m': {
                    threshold: 10,
                    indicatorWeights: { rsi: 1, macd: 1, stochRsi: 1, mfi: 1, trend: 1, occ: 1, stcCci: 1 },
                    lastAdjustment: Date.now(),
                    mode: 'normal',
                    performanceWindow: []
                },
                '1h': {
                    threshold: 10,
                    indicatorWeights: { rsi: 1, macd: 1, stochRsi: 1, mfi: 1, trend: 1, occ: 1, stcCci: 1 },
                    lastAdjustment: Date.now(),
                    mode: 'normal',
                    performanceWindow: []
                }
            }
        };
        
        let intervalId = null;
        
        // ============================================
        // FUNÇÕES DE UTILIDADE
        // ============================================
        function showNotification(title, subtitle, type = 'info', duration = 3000) {
            if (!config.visualNotifications) return;
            
            const now = Date.now();
            // Rate limit: apenas 1 notificação a cada 10 segundos
            if (now - state.lastNotification < 10000) return;
            state.lastNotification = now;
            
            const container = document.getElementById('notification-container');
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 12px;">
                    <div style="font-size: 32px; line-height: 1;">
                        ${type === 'success' ? '🚀' : type === 'danger' ? '📉' : 'ℹ️'}
                    </div>
                    <div style="flex: 1;">
                        <div style="font-weight: bold; font-size: 15px; margin-bottom: 4px;">${title}</div>
                        ${subtitle ? `<div style="font-size: 13px; opacity: 0.85;">${subtitle}</div>` : ''}
                    </div>
                </div>
            `;
            
            container.appendChild(notification);
            
            if (config.soundNotifications && type !== 'info') {
                playNotificationSound(type);
            }
            
            setTimeout(() => {
                notification.classList.add('hiding');
                setTimeout(() => notification.remove(), 300);
            }, duration);
        }
        
        function playNotificationSound(type) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = type === 'success' ? 800 : 400;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        }
        
        function updateBrasiliaTime() {
            const now = new Date();
            document.getElementById('current-time').textContent = now.toLocaleString('pt-BR', {
                timeZone: 'America/Sao_Paulo',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }
        
        function saveToLocalStorage(key, data) {
            try {
                localStorage.setItem(key, JSON.stringify(data));
                if (config.autoBackup) {
                    localStorage.setItem(`${key}_backup_${Date.now()}`, JSON.stringify(data));
                    cleanOldBackups(key);
                }
            } catch (e) {
                console.error('Erro ao salvar no localStorage:', e);
            }
        }
        
        function loadFromLocalStorage(key, defaultValue = null) {
            try {
                const data = localStorage.getItem(key);
                return data ? JSON.parse(data) : defaultValue;
            } catch (e) {
                console.error('Erro ao carregar do localStorage:', e);
                return defaultValue;
            }
        }
        
        function cleanOldBackups(key) {
            const backupKeys = Object.keys(localStorage).filter(k => k.startsWith(`${key}_backup_`));
            if (backupKeys.length > 5) {
                backupKeys.sort().slice(0, -5).forEach(k => localStorage.removeItem(k));
            }
        }
        
        // ============================================
        // 🧠 SISTEMA ADAPTATIVO (MACHINE LEARNING)
        // ============================================
        
        // Função para atualizar apenas os badges de peso no card
        function updateCardWeightBadges(timeframe) {
            const card = document.querySelector(`[data-timeframe="${timeframe}"]`);
            if (!card) {
                console.warn(`⚠️ Card ${timeframe} não encontrado`);
                return;
            }
            
            const adaptive = state.adaptiveSystem[timeframe];
            if (!adaptive || !adaptive.indicatorWeights) {
                console.warn(`⚠️ Sistema adaptativo não encontrado para ${timeframe}`);
                return;
            }
            
            // Atualizar badges para cada indicador
            Object.entries(adaptive.indicatorWeights).forEach(([key, weight]) => {
                console.log(`  🔍 Atualizando badge ${key}: peso ${weight.toFixed(1)}x`);
                
                const indicatorItem = card.querySelector(`[data-indicator="${key}"]`);
                if (!indicatorItem) {
                    console.warn(`    ❌ Elemento [data-indicator="${key}"] não encontrado`);
                    return;
                }
                
                const labelDiv = indicatorItem.querySelector('.indicator-label');
                if (!labelDiv) {
                    console.warn(`    ❌ .indicator-label não encontrado para ${key}`);
                    return;
                }
                
                // Remover TODOS os badges existentes (tanto com classe quanto sem classe, por segurança)
                const existingBadges = labelDiv.querySelectorAll('.weight-badge, span[style*="border-radius"]');
                console.log(`    🗑️ Removendo ${existingBadges.length} badges antigos`);
                existingBadges.forEach(badge => {
                    // Só remover se contém "x" no texto (ex: "1.0x")
                    if (badge.textContent && badge.textContent.includes('x')) {
                        badge.remove();
                    }
                });
                
                // Sempre adicionar badge (verde se >1, vermelho se <1, cinza se =1)
                const badge = document.createElement('span');
                badge.className = 'weight-badge';
                badge.style.cssText = `
                    display: inline-block;
                    font-size: 9px;
                    line-height: 1;
                    padding: 2px 5px;
                    background: ${weight > 1 ? 'rgba(2, 192, 118, 0.2)' : weight < 1 ? 'rgba(248, 73, 96, 0.2)' : '#444'};
                    color: ${weight > 1 ? 'var(--green)' : weight < 1 ? 'var(--red)' : '#aaa'};
                    border: 1px solid ${weight > 1 ? 'var(--green)' : weight < 1 ? 'var(--red)' : '#666'};
                    border-radius: 4px;
                    font-weight: bold;
                    white-space: nowrap;
                `;
                badge.textContent = `${weight.toFixed(1)}x`;
                labelDiv.appendChild(badge);
                console.log(`    ✅ Badge ${weight.toFixed(1)}x adicionado para ${key}`);
            });
            
            console.log(`✅ ${timeframe}: Badges de peso atualizados no card`);
        }
        
        function updateAdaptiveSystem(timeframe) {
            const adaptive = state.adaptiveSystem[timeframe];
            const history = state.tradeHistory[timeframe] || [];
            
            console.log(`📊 ${timeframe}: Total de trades no histórico: ${history.length}`);
            
            // Filtrar apenas trades validados E que NÃO sejam manuais
            const validated = history.filter(t => t.validated && !t.isManual);
            
            console.log(`📊 ${timeframe}: Trades validados (não-manuais): ${validated.length}`);
            validated.forEach((t, i) => {
                console.log(`  Trade ${i+1}: ${t.prediction}, Success: ${t.success}, isManual: ${t.isManual}, Indicators: ${!!t.indicators}`);
            });
            
            // Pegar últimos 10 trades validados (excluindo manuais)
            const recentTrades = validated.slice(-10);
            
            // 🎯 REQUER MÍNIMO DE 3 TRADES para começar a ajustar pesos
            const MIN_TRADES_FOR_WEIGHT_ADJUSTMENT = 3;
            
            if (validated.length < MIN_TRADES_FOR_WEIGHT_ADJUSTMENT) {
                console.log(`🔍 ${timeframe}: Apenas ${validated.length} trade(s) validado(s) - mínimo ${MIN_TRADES_FOR_WEIGHT_ADJUSTMENT} para ajustar pesos`);
                return; // Não ajusta pesos ainda
            }
            
            // AJUSTAR PESOS DO INDICADOR baseado no último trade
            const lastTrade = validated[validated.length - 1];
            
            // ⚠️ EVITAR PROCESSAR O MESMO TRADE MÚLTIPLAS VEZES
            if (lastTrade.weightsAdjusted) {
                console.log(`⚠️ ${timeframe}: Trade já teve pesos ajustados - pulando`);
                return;
            }
            
            console.log(`🔍 ${timeframe}: Último trade:`, lastTrade);
            console.log(`🔍 ${timeframe}: Tem indicadores?`, !!lastTrade?.indicators);
            
            if (lastTrade && lastTrade.indicators) {
                const isSuccess = lastTrade.success;
                const prediction = lastTrade.prediction;
                
                // Calcular variação de preço absoluta (a REAL variação do mercado)
                const priceVariation = Math.abs(((lastTrade.endPrice - lastTrade.entryPrice) / lastTrade.entryPrice) * 100);
                
                // Nota: NÃO usamos alavancagem aqui porque queremos medir a qualidade da previsão,
                // não o impacto no seu capital. Um indicador que prevê corretamente 0.1% é bom,
                // independente se você usa 1x ou 100x de alavancagem.
                
                console.log(`🔍 ${timeframe}: isSuccess=${isSuccess}, prediction=${prediction}, priceVariation=${priceVariation.toFixed(4)}%`);
                
                // Determinar ajuste baseado na variação REAL de preço
                let weightAdjustment = 0;
                if (priceVariation < 0.1) {
                    // Variação insignificante - não ajustar
                    console.log(`  ⚪ ${timeframe}: Variação ${priceVariation.toFixed(4)}% muito pequena - pesos mantidos`);
                    return; // Sai sem ajustar pesos
                } else if (priceVariation >= 0.1 && priceVariation < 1.0) {
                    weightAdjustment = 0.1;
                } else if (priceVariation >= 1.0 && priceVariation < 5.0) {
                    weightAdjustment = 0.2;
                } else { // >= 5%
                    weightAdjustment = 0.3;
                }
                
                console.log(`  📊 ${timeframe}: Variação de preço ${priceVariation.toFixed(4)}% → Ajuste de peso: ±${weightAdjustment}x`);
                
                // Para cada indicador que participou do trade
                Object.keys(lastTrade.indicators).forEach(key => {
                    const indicator = lastTrade.indicators[key];
                    const currentWeight = adaptive.indicatorWeights[key] || 1.0;
                    const indicatorStrength = Math.abs(indicator.score);
                    
                    // 🎯 LIMIAR MÍNIMO: Apenas indicadores com força >= 10% podem alterar pesos
                    const MIN_STRENGTH_THRESHOLD = 10;
                    
                    if (indicatorStrength < MIN_STRENGTH_THRESHOLD) {
                        console.log(`  ⚪ ${key}: ${indicator.score.toFixed(1)}% (força insuficiente, limiar = ${MIN_STRENGTH_THRESHOLD}%) - peso mantido em ${currentWeight.toFixed(1)}x`);
                        return; // Pula este indicador
                    }
                    
                    // Verificar se o indicador concordou com a predição
                    let indicatorAgreed = false;
                    if (prediction === 'COMPRA' && indicator.score > 0) {
                        indicatorAgreed = true;
                    } else if (prediction === 'VENDA' && indicator.score < 0) {
                        indicatorAgreed = true;
                    }
                    
                    // Se concordou com a predição
                    if (indicatorAgreed) {
                        if (isSuccess) {
                            // Trade deu certo e indicador concordou: AUMENTAR peso
                            const oldWeight = currentWeight;
                            adaptive.indicatorWeights[key] = Math.min(5.0, currentWeight + weightAdjustment);
                            console.log(`  ✅ ${key}: ${indicator.score.toFixed(1)}% - peso ${oldWeight.toFixed(1)}x → ${adaptive.indicatorWeights[key].toFixed(1)}x (acertou)`);
                            console.log(`  📌 CONFIRMAÇÃO: state.adaptiveSystem[${timeframe}].indicatorWeights[${key}] = ${adaptive.indicatorWeights[key]}`);
                        } else {
                            // Trade deu errado e indicador concordou: DIMINUIR peso
                            const oldWeight = currentWeight;
                            adaptive.indicatorWeights[key] = Math.max(0.1, currentWeight - weightAdjustment);
                            console.log(`  ❌ ${key}: ${indicator.score.toFixed(1)}% - peso ${oldWeight.toFixed(1)}x → ${adaptive.indicatorWeights[key].toFixed(1)}x (errou)`);
                            console.log(`  📌 CONFIRMAÇÃO: state.adaptiveSystem[${timeframe}].indicatorWeights[${key}] = ${adaptive.indicatorWeights[key]}`);
                        }
                    } else {
                        // Se discordou, não mexe no peso (estava certo em discordar)
                        if (isSuccess) {
                            console.log(`  ⚠️ ${key}: ${indicator.score.toFixed(1)}% - discordou da predição ${prediction} mas trade ACERTOU - peso mantido em ${currentWeight.toFixed(1)}x`);
                        } else {
                            console.log(`  🎯 ${key}: ${indicator.score.toFixed(1)}% - discordou da predição ${prediction} e trade ERROU - peso mantido em ${currentWeight.toFixed(1)}x (estava certo!)`);
                        }
                    }
                });
                
                // ✅ MARCAR TRADE COMO PROCESSADO
                lastTrade.weightsAdjusted = true;
                saveToLocalStorage(`tradeHistory_${config.symbol}`, state.tradeHistory);
                
                // 💾 SALVAR pesos ajustados no localStorage
                console.log(`💾 ${timeframe}: ANTES DE SALVAR - Pesos:`, JSON.stringify(state.adaptiveSystem[timeframe].indicatorWeights));
                saveToLocalStorage(`adaptiveSystem_${config.symbol}`, state.adaptiveSystem);
                console.log(`💾 ${timeframe}: Pesos salvos no localStorage`);
                console.log(`📊 ${timeframe}: Estado atual dos pesos:`, state.adaptiveSystem[timeframe].indicatorWeights);
                
                // 🔄 ATUALIZAR BADGES NO CARD
                updateCardWeightBadges(timeframe);
            } else {
                console.log(`⚠️ ${timeframe}: Trade sem indicadores salvos - não foi possível ajustar pesos`);
            }
            
            // ⚖️ AJUSTES DE THRESHOLD E MODO só com estatística mínima
            if (recentTrades.length < 5) {
                // Precisa de pelo menos 5 trades para ajustar threshold/modo
                console.log(`🧠 ${timeframe}: ${validated.length} trade(s) validado(s) - pesos ajustados, aguardando mais dados para threshold/modo`);
                return;
            }
            
            adaptive.performanceWindow = recentTrades;
            
            // Calcular Win Rate
            const wins = recentTrades.filter(t => t.success).length;
            const winRate = wins / recentTrades.length;
            
            console.log(`🧠 Analisando performance ${timeframe}: Win Rate = ${(winRate * 100).toFixed(0)}% | Threshold atual: ${adaptive.threshold}% | Modo: ${adaptive.mode}`);
            
            const previousMode = adaptive.mode;
            const consecutiveLosses = recentTrades.slice(-3).filter(t => !t.success).length;
            const consecutiveWins = recentTrades.slice(-3).filter(t => t.success).length;
            
            // PASSO 1️⃣: VERIFICAR MODO INVERSE PRIMEIRO (tem prioridade)
            
            // Entrar em modo INVERSE: mercado lateral detectado
            if (consecutiveLosses >= 2 && winRate < 0.4 && adaptive.mode !== 'inverse') {
                adaptive.mode = 'inverse';
                adaptive.threshold = Math.min(20, adaptive.threshold + 3);
                console.log(`  🔄 ${timeframe}: Detectado mercado lateral! Modo INVERSE ativado`);
            }
            
            // SAIR do modo INVERSE: condições melhoraram OU tendência forte apareceu
            else if (adaptive.mode === 'inverse') {
                // Sair se:
                // 1. Win Rate > 45% (melhorou significativamente)
                // 2. Win Rate > 40% E (ganhou 2+ seguidos OU apenas 1 perda nos últimos 3)
                const winRateGood = winRate > 0.45;
                const winRateOk = winRate > 0.40 && (consecutiveWins >= 2 || consecutiveLosses <= 1);
                
                const shouldExit = winRateGood || winRateOk;
                
                if (shouldExit) {
                    adaptive.mode = 'normal';
                    const reason = winRate > 0.45 ? 
                        `Win Rate melhorou (${(winRate * 100).toFixed(0)}%)` : 
                        consecutiveWins >= 2 ? 
                            'Ganhos consecutivos' : 
                            'Mercado normalizou';
                    console.log(`  ✅ ${timeframe}: Saindo do modo INVERSE! ${reason}`);
                } else {
                    console.log(`  🔄 ${timeframe}: Mantendo modo INVERSE (Win Rate: ${(winRate * 100).toFixed(0)}%, perdas: ${consecutiveLosses}/3)`);
                }
            }
            
            // PASSO 2️⃣: AJUSTAR THRESHOLD baseado em Win Rate (se NÃO estiver em modo INVERSE)
            if (adaptive.mode !== 'inverse') {
                if (winRate < 0.30) {
                    // Péssimo! Ficar MUITO mais seletivo
                    adaptive.threshold = Math.min(25, adaptive.threshold + 3);
                    adaptive.mode = 'conservative';
                    console.log(`  🛡️ ${timeframe}: Win Rate CRÍTICO! Threshold → ${adaptive.threshold}%`);
                } else if (winRate < 0.40) {
                    // Ruim! Ficar mais seletivo
                    adaptive.threshold = Math.min(20, adaptive.threshold + 2);
                    adaptive.mode = 'conservative';
                    console.log(`  ⚠️ ${timeframe}: Win Rate baixo! Threshold → ${adaptive.threshold}%`);
                } else if (winRate > 0.70) {
                    // Excelente! Pode ser mais agressivo
                    adaptive.threshold = Math.max(5, adaptive.threshold - 2);
                    adaptive.mode = 'aggressive';
                    console.log(`  🚀 ${timeframe}: Win Rate ALTO! Threshold → ${adaptive.threshold}%`);
                } else if (winRate > 0.55 && winRate <= 0.70) {
                    // Bom! Voltar gradualmente ao normal
                    if (adaptive.threshold > 10) {
                        adaptive.threshold = Math.max(10, adaptive.threshold - 1);
                        console.log(`  📉 ${timeframe}: Melhorando! Threshold → ${adaptive.threshold}%`);
                    }
                    adaptive.mode = 'normal';
                } else {
                    // Win Rate entre 40-55% = Normal
                    // Só ajustar threshold gradualmente de volta ao padrão
                    if (adaptive.threshold > 10) {
                        adaptive.threshold = Math.max(10, adaptive.threshold - 1);
                        console.log(`  ⚖️ ${timeframe}: Normalizando threshold → ${adaptive.threshold}%`);
                    } else if (adaptive.threshold < 10) {
                        adaptive.threshold = Math.min(10, adaptive.threshold + 1);
                        console.log(`  ⚖️ ${timeframe}: Normalizando threshold → ${adaptive.threshold}%`);
                    }
                    adaptive.mode = 'normal';
                }
            }
            
            // Log de mudança de modo
            if (previousMode !== adaptive.mode) {
                console.log(`  🔄 ${timeframe}: Modo alterado: ${previousMode} → ${adaptive.mode}`);
            }
            
            adaptive.lastAdjustment = Date.now();
            
            // Salvar no localStorage
            saveToLocalStorage(`adaptiveSystem_${config.symbol}`, state.adaptiveSystem);
        }
        
        function applyAdaptiveWeights(timeframe, indicators) {
            const adaptive = state.adaptiveSystem[timeframe];
            if (!adaptive) return indicators;
            
            // Retornar indicadores SEM multiplicar pelos pesos (faremos isso depois)
            // Apenas manter a estrutura de dados limpa
            return indicators;
        }
        
        function getAdaptiveThreshold(timeframe) {
            return state.adaptiveSystem[timeframe]?.threshold || 10;
        }
        
        function getAdaptiveMode(timeframe) {
            return state.adaptiveSystem[timeframe]?.mode || 'normal';
        }
        
        function loadAdaptiveSystem() {
            try {
                const data = localStorage.getItem(`adaptiveSystem_${config.symbol}`);
                if (data) {
                    const loaded = JSON.parse(data);
                    // Mesclar com valores padrão
                    Object.keys(loaded).forEach(tf => {
                        if (state.adaptiveSystem[tf]) {
                            state.adaptiveSystem[tf] = { ...state.adaptiveSystem[tf], ...loaded[tf] };
                        }
                    });
                    console.log('🧠 Sistema adaptativo carregado do localStorage');
                }
            } catch (e) {
                console.error('Erro ao carregar sistema adaptativo:', e);
            }
        }
        
        // CORREÇÃO #2: Salvar/carregar priceTracker do localStorage
        function savePriceTracker() {
            try {
                localStorage.setItem(`priceTracker_${config.symbol}`, JSON.stringify(state.priceTracker));
            } catch (e) {
                console.error('Erro ao salvar priceTracker:', e);
            }
        }
        
        function loadPriceTracker() {
            try {
                const data = localStorage.getItem(`priceTracker_${config.symbol}`);
                state.priceTracker = data ? JSON.parse(data) : {};
            } catch (e) {
                console.error('Erro ao carregar priceTracker:', e);
                state.priceTracker = {};
            }
        }
        
        // ============================================
        // GESTÃO DE WEBSOCKETS
        // ============================================
        function setupWebSocket(url, onMessage, statusDotId) {
            const socket = new WebSocket(url);
            
            socket.onopen = () => {
                console.log(`WebSocket conectado: ${url}`);
                document.getElementById(statusDotId).classList.add('connected');
            };
            
            socket.onmessage = onMessage;
            
            socket.onerror = (error) => {
                console.error(`Erro no WebSocket ${url}:`, error);
            };
            
            socket.onclose = () => {
                console.log(`WebSocket desconectado: ${url}`);
                document.getElementById(statusDotId).classList.remove('connected');
                
                setTimeout(() => {
                    if (config.whaleTracking || statusDotId !== 'status-dot-whale') {
                        setupWebSocket(url, onMessage, statusDotId);
                    }
                }, 3000);
            };
            
            return socket;
        }
        
        // ============================================
        // ANÁLISE TÉCNICA MELHORADA
        // ============================================
        async function performAnalysis() {
            // Prevenir análises simultâneas
            if (state.isAnalyzing) {
                console.log('⏳ Análise já em andamento, aguardando...');
                return;
            }
            
            const now = Date.now();
            if (now - state.lastAnalysisTime < config.refreshInterval - 500) return;
            
            state.isAnalyzing = true;
            state.lastAnalysisTime = now;
            document.getElementById('last-update').textContent = new Date().toLocaleTimeString('pt-BR');
            
            try {
                const symbol = config.symbol;
                const timeframes = ['1m', '5m', '15m', '1h'];
                
                console.log('Iniciando análise para', symbol);
                
                // Buscar dados em paralelo
                const [klinesData, fearGreedData, tickerData] = await Promise.all([
                    Promise.all(timeframes.map(interval => 
                        axios.get(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=200`)
                    )),
                    axios.get('https://api.alternative.me/fng/?limit=1').catch(() => ({
                        data: { data: [{ value: 50, value_classification: 'Neutral' }] }
                    })),
                    axios.get(`https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`)
                ]);
                
                console.log('Dados recebidos com sucesso');
                
                // Atualizar informações de preço
                const ticker = tickerData.data;
                state.currentPrice = parseFloat(ticker.lastPrice);
                state.priceChangePercent = parseFloat(ticker.priceChangePercent);
                
                document.getElementById('current-price').textContent = `$${state.currentPrice.toFixed(2)}`;
                const changeEl = document.getElementById('price-change');
                changeEl.textContent = `${state.priceChangePercent >= 0 ? '+' : ''}${state.priceChangePercent.toFixed(2)}%`;
                changeEl.style.color = state.priceChangePercent >= 0 ? 'var(--green)' : 'var(--red)';
                
                // Volume em dólares = volume em BTC × preço atual em USD
                const volumeInUSD = parseFloat(ticker.volume) * state.currentPrice;
                const volumeFormatted = volumeInUSD >= 1e9 
                    ? `$${(volumeInUSD / 1e9).toFixed(2)}B` 
                    : `$${(volumeInUSD / 1e6).toFixed(2)}M`;
                document.getElementById('volume-24h').textContent = volumeFormatted;
                document.getElementById('high-24h').textContent = `$${parseFloat(ticker.highPrice).toFixed(2)}`;
                document.getElementById('low-24h').textContent = `$${parseFloat(ticker.lowPrice).toFixed(2)}`;
                
                // Avaliar decisões pendentes com o preço atual
                if (typeof window.DecisionEvaluator !== 'undefined') {
                    window.DecisionEvaluator.evaluatePendingDecisions(state.currentPrice);
                }
                
                // Analisar cada timeframe
                console.log('Analisando timeframes...');
                const analyses = timeframes.map((tf, i) => {
                    try {
                        return analyzeTimeframe(tf, klinesData[i].data);
                    } catch (error) {
                        console.error(`Erro ao analisar ${tf}:`, error);
                        return null;
                    }
                }).filter(a => a !== null);
                
                if (analyses.length === 0) {
                    throw new Error('Nenhuma análise válida foi gerada. Verifique o console.');
                }
                
                console.log('Análises geradas:', analyses.length);
                
                // Rastrear trades para cada timeframe
                analyses.forEach(analysis => {
                    trackTrade(analysis.timeframe, analysis);
                });
                
                // Calcular confiança geral
                const confidence = calculateOverallConfidence(analyses, fearGreedData.data.data[0]);
                
                // Atualizar UI
                updateUI(analyses, confidence, fearGreedData.data.data[0]);
                
                // Validar trades anteriores
                validateTrades(state.currentPrice);
                
                // Atualizar estatísticas gerais
                updateOverallStats();
                
                // 🧠 VERIFICAÇÃO PERIÓDICA: Atualizar sistema adaptativo a cada 10 análises
                if (!state.adaptiveCheckCounter) state.adaptiveCheckCounter = 0;
                state.adaptiveCheckCounter++;
                
                if (state.adaptiveCheckCounter >= 10) {
                    console.log('╔══════════════════════════════════════════╗');
                    console.log('║ 🧠 VERIFICAÇÃO PERIÓDICA DO SISTEMA     ║');
                    console.log('╚══════════════════════════════════════════╝');
                    
                    // Debug: Mostrar estado atual de todos os timeframes
                    Object.keys(state.tradeHistory).forEach(tf => {
                        const all = state.tradeHistory[tf] || [];
                        const validated = all.filter(t => t.validated);
                        const pending = all.filter(t => !t.validated);
                        
                        console.log(`  📊 ${tf}: ${all.length} trades (${validated.length} validados, ${pending.length} pendentes)`);
                        
                        if (validated.length >= 5) {
                            updateAdaptiveSystem(tf);
                        } else {
                            console.log(`     ⏳ Aguardando mais dados (mínimo 5 validados)`);
                        }
                    });
                    
                    state.adaptiveCheckCounter = 0;
                    updateAdaptiveStatusCard(); // Atualizar card visual
                }
                
                console.log('Análise concluída com sucesso');
                
            } catch (error) {
                console.error('ERRO DETALHADO:', error);
                console.error('Stack trace:', error.stack);
                
                // Não mostrar notificação se for erro de bibliotecas carregando
                if (!error.message.includes('Aguardando')) {
                    showNotification('Erro na Análise', error.message || 'Verifique o console', 'danger', 3000);
                }
            } finally {
                // Sempre liberar flag de análise
                state.isAnalyzing = false;
            }
        }
        
        function analyzeTimeframe(timeframe, klines) {
            // CORREÇÃO CRÍTICA #1: Usar apenas velas FECHADAS (não a atual)
            const closedCandles = klines.slice(0, -1); // Remove última vela (aberta)

            // Cache baseado na última vela FECHADA
            const lastClosedCandle = closedCandles[closedCandles.length - 1];
            const cacheKey = `${config.symbol}_${timeframe}_${lastClosedCandle[0]}_${lastClosedCandle[4]}`;

            if (state.indicatorCache[cacheKey]) {
                const cached = state.indicatorCache[cacheKey];
                // Atualizar preço live da análise cached
                const currentLivePrice = parseFloat(klines[klines.length - 1][4]);
                cached.currentPrice = currentLivePrice;
                return cached;
            }

            // Usar o engine de análise independente
            const marketData = {
                klines: klines,
                timeframe: timeframe,
                config: config
            };

            let analysisResult;
            try {
                analysisResult = MarketAnalysisEngine.analyzeMarket(marketData);
            } catch (error) {
                console.error(`Erro no engine para ${timeframe}:`, error);
                // Retornar análise neutra em caso de erro
                return {
                    timeframe,
                    direction: 'NEUTRO',
                    score: 0,
                    currentPrice: parseFloat(klines[klines.length - 1][4]),
                    atr: 0,
                    indicators: {
                        rsi: { value: 50, score: 0 },
                        macd: { value: 0, score: 0 },
                        stochRsi: { value: 50, score: 0 },
                        mfi: { value: 50, score: 0 },
                        trend: { value: 'sideways', score: 0 },
                        occ: { value: 0, score: 0 },
                        stcCci: { value: 0, score: 0 }
                    },
                    trend: 'sideways',
                    divergence: null,
                    volume: 0,
                    avgVolume: 0,
                    confidence: 50,
                    explanation: 'Erro na análise técnica'
                };
            }

            // Adaptar o resultado do engine para o formato esperado pelo frontend
            const analysis = {
                timeframe: analysisResult.timeframe,
                direction: analysisResult.direction === 'BUY' ? 'COMPRA' :
                          analysisResult.direction === 'SELL' ? 'VENDA' : 'NEUTRO',
                score: analysisResult.totalScore,
                currentPrice: analysisResult.indicators.currentPrice,
                atr: analysisResult.indicators.atr,
                indicators: {
                    rsi: {
                        value: analysisResult.indicators.rsi.value,
                        score: analysisResult.scores.rsi.score
                    },
                    macd: {
                        value: analysisResult.indicators.macd.value,
                        score: analysisResult.scores.macd.score
                    },
                    stochRsi: {
                        value: analysisResult.indicators.stochRsi.value,
                        score: analysisResult.scores.stochRsi.score
                    },
                    mfi: {
                        value: analysisResult.indicators.mfi.value,
                        score: analysisResult.scores.mfi.score
                    },
                    trend: {
                        value: analysisResult.indicators.trend.value,
                        score: analysisResult.scores.trend.score
                    },
                    occ: {
                        value: analysisResult.indicators.occ?.value || 0,
                        score: analysisResult.scores.occ?.score || 0
                    },
                    stcCci: {
                        value: analysisResult.indicators.stcCci?.value || 0,
                        score: analysisResult.scores.stcCci?.score || 0
                    }
                },
                trend: analysisResult.indicators.trend.value,
                divergence: analysisResult.indicators.divergence.value,
                volume: analysisResult.indicators.volume,
                avgVolume: analysisResult.indicators.avgVolume,
                confidence: analysisResult.confidence,
                explanation: analysisResult.explanation
            };

            // Registrar decisão para avaliação posterior
            if (typeof window.DecisionEvaluator !== 'undefined') {
                window.DecisionEvaluator.recordDecision({
                    direction: analysisResult.direction,
                    confidence: analysisResult.confidence,
                    currentPrice: analysisResult.indicators.currentPrice,
                    indicators: analysisResult.indicators,
                    timeframe: analysisResult.timeframe,
                    explanation: analysisResult.explanation,
                    marketContext: {
                        totalScore: analysisResult.totalScore,
                        marketRegime: analysisResult.indicators.trend.value,
                        relativeVolatility: (analysisResult.indicators.atr / analysisResult.indicators.currentPrice) * 100
                    }
                });
            }

            // CORREÇÃO #5: Cache por 4 segundos (não 2)
            state.indicatorCache[cacheKey] = analysis;
            setTimeout(() => delete state.indicatorCache[cacheKey], 4000);

            return analysis;
        }
        

        
        function calculateOverallConfidence(analyses, fearGreed) {
            // Usar o SCORE (com sinal) em vez da confidence
            // Score negativo = VENDA (0-50%), Score positivo = COMPRA (50-100%)
            const avgScore = analyses.reduce((sum, a) => sum + (a.score || 0), 0) / analyses.length;
            
            // Converter score para porcentagem 0-100%
            // Score -100 = 0%, Score 0 = 50%, Score +100 = 100%
            let finalConfidence = 50 + (avgScore / 2);

            // Ajustar por Fear & Greed
            const fngValue = parseInt(fearGreed.value);
            if (fngValue < 25) finalConfidence += 8;
            else if (fngValue > 75) finalConfidence -= 8;

            // Ajustar por pressão de baleias
            if (config.whaleTracking) {
                finalConfidence += (state.whaleSummary.buyPressure - 0.5) * 15;
            }

            // Confluência entre timeframes
            const bullishCount = analyses.filter(a => a.direction === 'COMPRA').length;
            const bearishCount = analyses.filter(a => a.direction === 'VENDA').length;

            if (bullishCount >= 3) finalConfidence += 10;
            else if (bearishCount >= 3) finalConfidence -= 10;

            return Math.max(0, Math.min(100, finalConfidence));
        }
        
        // ============================================
        // ATUALIZAÇÃO DA UI
        // ============================================
        function updateUI(analyses, confidence, fearGreed) {
            // Atualizar confiança geral
            const direction = confidence > 52 ? 'COMPRA' : confidence < 48 ? 'VENDA' : 'NEUTRO';
            
            document.getElementById('confidence-percent').textContent = `${confidence.toFixed(0)}%`;
            document.getElementById('confidence-indicator').style.left = `${confidence}%`;
            
            const signalEl = document.getElementById('current-signal');
            signalEl.textContent = direction;
            signalEl.className = `signal-badge ${direction === 'COMPRA' ? 'buy' : direction === 'VENDA' ? 'sell' : 'neutral'}`;
            
            // Atualizar Fear & Greed
            const fngEl = document.getElementById('fng-value');
            fngEl.textContent = `${fearGreed.value} (${fearGreed.value_classification})`;
            fngEl.style.color = fearGreed.value > 55 ? 'var(--green)' : fearGreed.value < 45 ? 'var(--red)' : 'var(--accent)';
            
            // Renderizar cards de indicadores
            const resultDiv = document.getElementById('result');
            
            if (!resultDiv.querySelector('.indicators-grid')) {
                resultDiv.innerHTML = '<div class="indicators-grid"></div>';
            }
            
            const gridContainer = resultDiv.querySelector('.indicators-grid');
            
            console.log('Atualizando UI com', analyses.length, 'análises');
            console.log('Timeframes:', analyses.map(a => a.timeframe));
            
            // NÃO apagar tudo! Apenas atualizar os cards existentes
            analyses.forEach(analysis => {
                console.log(`📊 Processando ${analysis.timeframe}:`, {
                    direction: analysis.direction,
                    score: analysis.score
                });
                
                // Verificar se o card já existe
                let existingCard = gridContainer.querySelector(`[data-timeframe="${analysis.timeframe}"]`);
                console.log(`  Card existe?`, !!existingCard);
                
                if (!existingCard) {
                    // Se não existe, criar novo
                    console.log(`  🆕 Criando novo card...`);
                    try {
                        const newCard = createIndicatorCard(analysis);
                        gridContainer.appendChild(newCard);
                        console.log(`  ✅ Card criado!`);
                        
                        // Limpar possíveis badges duplicados logo após criar
                        setTimeout(() => {
                            updateCardWeightBadges(analysis.timeframe);
                        }, 50);
                        
                        // Verificar histórico
                        const histEl = document.getElementById(`history-${analysis.timeframe}`);
                        console.log(`  📜 history-${analysis.timeframe} criado?`, !!histEl);
                        
                        // Atualizar estatísticas após criar
                        setTimeout(() => updateHistoryStats(analysis.timeframe), 100);
                    } catch (error) {
                        console.error(`Erro ao criar card ${analysis.timeframe}:`, error);
                    }
                } else {
                    // Se existe, apenas atualizar o conteúdo necessário
                    console.log(`Atualizando card existente para ${analysis.timeframe}`);
                    try {
                        updateExistingCard(existingCard, analysis);
                    } catch (error) {
                        console.error(`Erro ao atualizar card ${analysis.timeframe}:`, error);
                    }
                }
            });
            
            // Notificar APENAS quando a MÉDIA GERAL dos indicadores estiver >= 75%
            if (config.visualNotifications) {
                analyses.forEach(tf => {
                    // Calcular média geral dos indicadores
                    const avgScore = Object.values(tf.indicators).reduce((sum, ind) => sum + ind.score, 0) / Object.keys(tf.indicators).length;
                    const normalizedAvg = Math.max(-100, Math.min(100, avgScore));
                    
                    // Verificar se já notificou recentemente este timeframe
                    const notifKey = `lastNotif_${tf.timeframe}_${normalizedAvg > 0 ? 'buy' : 'sell'}`;
                    const lastNotifTime = sessionStorage.getItem(notifKey) || 0;
                    
                    // Notificar apenas se média >= 75% ou <= -75% E não notificou no último minuto
                    if (Date.now() - lastNotifTime > 60000) {
                        if (normalizedAvg >= 75) {
                            showNotification(
                                `🚀 ${tf.timeframe.toUpperCase()} - Sinal FORTE de COMPRA`,
                                `Média dos indicadores: +${normalizedAvg.toFixed(0)}%`,
                                'success', 
                                8000
                            );
                            sessionStorage.setItem(notifKey, Date.now());
                        } else if (normalizedAvg <= -75) {
                            showNotification(
                                `📉 ${tf.timeframe.toUpperCase()} - Sinal FORTE de VENDA`,
                                `Média dos indicadores: ${normalizedAvg.toFixed(0)}%`,
                                'danger', 
                                8000
                            );
                            sessionStorage.setItem(notifKey, Date.now());
                        }
                    }
                });
            }
            
            // Atualizar countdown
            updateCountdown();
        }
        
        function createIndicatorCard(analysis) {
            const card = document.createElement('div');
            card.className = `indicator-card ${analysis.direction === 'COMPRA' ? 'bullish' : analysis.direction === 'VENDA' ? 'bearish' : ''}`;
            card.setAttribute('data-timeframe', analysis.timeframe);
            
            const isHighVolume = analysis.volume > analysis.avgVolume * 1.5;
            
            // 🧠 Obter status do sistema adaptativo
            const adaptiveMode = getAdaptiveMode(analysis.timeframe);
            const adaptiveThreshold = getAdaptiveThreshold(analysis.timeframe);
            
            // Verificar se há pesos modificados
            const adaptiveSystem = state.adaptiveSystem?.[analysis.timeframe];
            const hasModifiedWeights = adaptiveSystem?.indicatorWeights 
                ? Object.values(adaptiveSystem.indicatorWeights).some(w => w !== 1)
                : false;
            
            // Verificar quantos trades validados existem (excluindo manuais)
            const validatedTrades = (state.tradeHistory[analysis.timeframe] || []).filter(t => t.validated && !t.isManual).length;
            const needsMoreTrades = validatedTrades === 0; // Mostra "aguardando" apenas se não tem nenhum trade
            
            // Sistema é considerado ativo se: modo diferente de normal OU threshold diferente de 10 OU pesos modificados OU tem pelo menos 1 trade validado
            const isAdaptive = adaptiveMode !== 'normal' || adaptiveThreshold !== 10 || hasModifiedWeights || validatedTrades > 0;
            
            const adaptiveBadges = {
                'conservative': { emoji: '🛡️', text: 'Modo Conservador', color: 'var(--orange)' },
                'aggressive': { emoji: '🚀', text: 'Modo Agressivo', color: 'var(--green)' },
                'inverse': { emoji: '🔄', text: 'Modo Inverso', color: 'var(--accent)' },
                'normal': { emoji: '🧠', text: 'Ajuste Ativo', color: 'var(--accent)' }
            };
            
            card.innerHTML = `
                <div class="timeframe-header">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div class="timeframe-title">${analysis.timeframe.toUpperCase()}</div>
                        <div style="font-size: 11px; color: var(--accent); font-weight: bold; background: rgba(240, 185, 11, 0.1); padding: 3px 8px; border-radius: 4px;">
                            Score: ${analysis.score > 0 ? '+' : ''}${analysis.score.toFixed(0)}
                        </div>
                        ${needsMoreTrades ? `
                            <span style="
                                font-size: 10px; 
                                padding: 3px 8px; 
                                background: var(--bg-light); 
                                color: var(--text-secondary); 
                                border-radius: 8px;
                                font-weight: bold;
                                display: inline-block;
                            " title="Aguardando primeiro trade validado">
                                ⏳ Aguardando dados
                            </span>
                        ` : isAdaptive ? `
                            <span style="
                                font-size: 10px; 
                                padding: 3px 8px; 
                                background: ${adaptiveBadges[adaptiveMode].color}; 
                                color: white; 
                                border-radius: 8px;
                                font-weight: bold;
                                display: inline-block;
                            " title="Sistema adaptativo ativo (${validatedTrades} trade(s) analisado(s))">
                                ${adaptiveBadges[adaptiveMode].emoji} ${adaptiveBadges[adaptiveMode].text}
                            </span>
                        ` : ''}
                    </div>
                    <span class="signal-badge ${analysis.direction === 'COMPRA' ? 'buy' : analysis.direction === 'VENDA' ? 'sell' : 'neutral'}">
                        ${analysis.direction}
                    </span>
                </div>
                
                ${isAdaptive && !needsMoreTrades ? `
                    <div style="font-size: 10px; color: ${adaptiveBadges[adaptiveMode].color}; margin-bottom: 8px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; border-left: 3px solid ${adaptiveBadges[adaptiveMode].color};">
                        <div style="font-weight: bold; margin-bottom: 4px;">🧠 SISTEMA ADAPTATIVO ATIVO</div>
                        <div>Threshold: ${adaptiveThreshold}% (padrão: 10%)</div>
                        <div style="margin-top: 2px;">${adaptiveMode === 'inverse' ? '🔄 Mercado lateral detectado - sinais invertidos' : adaptiveMode === 'conservative' ? '🛡️ Win Rate baixo - mais seletivo' : adaptiveMode === 'aggressive' ? '⚡ Win Rate alto - mais agressivo' : '⚙️ Ajustando parâmetros'}</div>
                        ${(() => {
                            const modifiedWeights = Object.entries(state.adaptiveSystem[analysis.timeframe]?.indicatorWeights || {}).filter(([_, w]) => w !== 1);
                            return modifiedWeights.length > 0 ? `
                                <div style="margin-top: 4px; font-size: 9px; opacity: 0.9;">
                                    🎯 ${modifiedWeights.length} indicador(es) com peso ajustado
                                </div>
                            ` : '';
                        })()}
                    </div>
                ` : ''}
                
                ${analysis.trend !== 'sideways' ? `
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px;">
                        📊 Tendência: <strong style="color: ${analysis.trend === 'uptrend' ? 'var(--green)' : 'var(--red)'}">
                            ${analysis.trend === 'uptrend' ? 'Alta' : 'Baixa'}
                        </strong>
                        ${isHighVolume ? ' • 📈 Volume Alto' : ''}
                        ${analysis.divergence ? ` • ⚡ Divergência ${analysis.divergence === 'bullish' ? 'Alta' : 'Baixa'}` : ''}
                    </div>
                ` : ''}
                
                <div class="indicator-strength-list">
                    ${Object.entries(analysis.indicators).map(([key, data]) => {
                        console.log(`📊 ${analysis.timeframe} - ${key}: data.score=${data.score}, data.value=${data.value}`);
                        const normalizedScore = Math.max(-100, Math.min(100, data.score));
                        const percentage = normalizedScore;
                        
                        // Verificar peso adaptativo (sempre mostrar badge)
                        const adaptive = state.adaptiveSystem[analysis.timeframe];
                        const weight = adaptive?.indicatorWeights[key] || 1;
                        
                        // Converter de -100/+100 para 0-100% (50% = neutro)
                        const barPercentage = 50 + (percentage / 2);
                        
                        return `
                        <div class="indicator-strength-item" data-indicator="${key}">
                            <div class="indicator-label" style="display: flex; align-items: center; gap: 6px;">
                                ${getIndicatorLabel(key, analysis.timeframe)}
                                <span class="weight-badge" style="
                                    display: inline-block;
                                    font-size: 9px;
                                    line-height: 1;
                                    padding: 2px 5px;
                                    background: ${weight > 1 ? 'rgba(2, 192, 118, 0.2)' : weight < 1 ? 'rgba(248, 73, 96, 0.2)' : '#444'};
                                    color: ${weight > 1 ? 'var(--green)' : weight < 1 ? 'var(--red)' : '#aaa'};
                                    border: 1px solid ${weight > 1 ? 'var(--green)' : weight < 1 ? 'var(--red)' : '#666'};
                                    border-radius: 4px;
                                    font-weight: bold;
                                    white-space: nowrap;
                                ">${weight.toFixed(1)}x</span>
                            </div>
                            <div class="indicator-bar-container" style="position: relative; background: linear-gradient(to right, var(--red) 0%, var(--bg-dark) 50%, var(--green) 100%);">
                                <!-- Linha central (50%) -->
                                <div style="position: absolute; left: 50%; width: 2px; height: 100%; background-color: var(--text-primary); opacity: 0.4; z-index: 2;"></div>
                                
                                <!-- Barra de preenchimento -->
                                <div style="
                                    position: absolute;
                                    left: 0;
                                    width: ${barPercentage}%;
                                    height: 100%;
                                    background: ${percentage > 0 ? 'rgba(2, 192, 118, 0.3)' : 'rgba(248, 73, 96, 0.3)'};
                                    transition: width 0.5s ease;
                                "></div>
                                
                                <!-- Indicador de posição atual -->
                                <div style="
                                    position: absolute;
                                    left: ${barPercentage}%;
                                    width: 4px;
                                    height: 100%;
                                    background-color: ${percentage > 25 ? 'var(--green)' : percentage < -25 ? 'var(--red)' : 'var(--accent)'};
                                    box-shadow: 0 0 8px ${percentage > 25 ? 'var(--green)' : percentage < -25 ? 'var(--red)' : 'var(--accent)'};
                                    transform: translateX(-50%);
                                    z-index: 3;
                                    transition: left 0.5s ease;
                                "></div>
                            </div>
                            <div class="indicator-percent" style="color: ${percentage > 25 ? 'var(--green)' : percentage < -25 ? 'var(--red)' : 'var(--text-secondary)'}; font-weight: bold;">
                                ${percentage > 0 ? '+' : ''}${percentage.toFixed(0)}%
                            </div>
                        </div>
                    `}).join('')}
                </div>
                
                <!-- Botão Resetar Pesos -->
                <div style="margin-top: 12px; padding: 0 8px;">
                    <button class="btn btn-secondary" onclick="resetIndicatorWeights('${analysis.timeframe}')" 
                            style="width: 100%; background: linear-gradient(135deg, #ff9800, #ff6f00); font-size: 11px; padding: 8px; border: none; color: white; font-weight: bold; border-radius: 6px; cursor: pointer; transition: all 0.2s;"
                            onmouseover="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(255, 152, 0, 0.4)';" 
                            onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';">
                        🔄 Resetar Pesos (1.0x)
                    </button>
                </div>
                
                <!-- Média Geral dos Indicadores -->
                <div style="margin-top: 15px; padding: 0 8px;">
                    <div class="indicator-strength-item" data-indicator="average" style="background-color: var(--bg-dark); padding: 8px; border-radius: 6px; border: 2px solid var(--accent);">
                        <div class="indicator-label" style="color: var(--accent); font-weight: bold;">📊 MÉDIA GERAL</div>
                        <div class="indicator-bar-container" style="position: relative; border: 2px solid var(--accent); background: linear-gradient(to right, var(--red) 0%, var(--bg-dark) 50%, var(--green) 100%);">
                            <!-- Linha central (50%) -->
                            <div style="position: absolute; left: 50%; width: 2px; height: 100%; background-color: var(--accent); opacity: 0.6; z-index: 2;"></div>
                            
                            ${(() => {
                                const avgScore = Object.values(analysis.indicators).reduce((sum, ind) => sum + ind.score, 0) / Object.keys(analysis.indicators).length;
                                const normalizedAvg = Math.max(-100, Math.min(100, avgScore));
                                const barPercentage = 50 + (normalizedAvg / 2);
                                
                                return `
                                    <!-- Barra de preenchimento -->
                                    <div style="
                                        position: absolute;
                                        left: 0;
                                        width: ${barPercentage}%;
                                        height: 100%;
                                        background: ${normalizedAvg > 0 ? 'rgba(2, 192, 118, 0.4)' : 'rgba(248, 73, 96, 0.4)'};
                                        transition: width 0.5s ease;
                                    "></div>
                                    
                                    <!-- Indicador de posição atual -->
                                    <div style="
                                        position: absolute;
                                        left: ${barPercentage}%;
                                        width: 4px;
                                        height: 100%;
                                        background-color: var(--accent);
                                        box-shadow: 0 0 12px var(--accent);
                                        transform: translateX(-50%);
                                        z-index: 3;
                                        transition: left 0.5s ease;
                                    "></div>
                                `;
                            })()}
                        </div>
                        <div class="indicator-percent" style="color: var(--accent); font-weight: bold; font-size: 14px;">
                            ${(() => {
                                const avgScore = Object.values(analysis.indicators).reduce((sum, ind) => sum + ind.score, 0) / Object.keys(analysis.indicators).length;
                                const normalizedAvg = Math.max(-100, Math.min(100, avgScore));
                                return `${normalizedAvg > 0 ? '+' : ''}${normalizedAvg.toFixed(0)}%`;
                            })()}
                        </div>
                    </div>
                </div>
                
                <div class="indicator-strength-list">
                </div>
                
                <div class="trade-suggestions">
                    <div class="trade-row">
                        <span class="trade-label">Entrada Sugerida:</span>
                        <span class="trade-value" data-price="entry">$${analysis.currentPrice.toFixed(5)}</span>
                    </div>
                    <div class="trade-row">
                        <span class="trade-label" style="color: var(--green);">Take Profit:</span>
                        <span class="trade-value" style="color: var(--green);" data-price="tp">
                            $${(analysis.direction === 'COMPRA' ? 
                                analysis.currentPrice + (3 * analysis.atr) : 
                                analysis.currentPrice - (3 * analysis.atr)
                            ).toFixed(5)}
                        </span>
                    </div>
                    <div class="trade-row">
                        <span class="trade-label" style="color: var(--red);">Stop Loss:</span>
                        <span class="trade-value" style="color: var(--red);" data-price="sl">
                            $${(analysis.direction === 'COMPRA' ? 
                                analysis.currentPrice - (1.5 * analysis.atr) : 
                                analysis.currentPrice + (1.5 * analysis.atr)
                            ).toFixed(5)}
                        </span>
                    </div>
                </div>
                
                <!-- Botões de Trade Manual -->
                <div style="margin-top: 12px; padding: 0 8px; display: flex; gap: 12px;">
                    <button onclick="manualTrade('${analysis.timeframe}', 'BUY')" 
                            style="flex: 1; padding: 12px; background: linear-gradient(135deg, var(--green), #00a884); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 13px; transition: all 0.2s;" 
                            onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(2, 192, 118, 0.4)';" 
                            onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';">
                        📈 COMPRA
                    </button>
                    <button onclick="manualTrade('${analysis.timeframe}', 'SELL')" 
                            style="flex: 1; padding: 12px; background: linear-gradient(135deg, var(--red), #d63c52); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 13px; transition: all 0.2s;" 
                            onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(248, 73, 96, 0.4)';" 
                            onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';">
                        📉 VENDA
                    </button>
                </div>
                
                <div class="history-section">
                    <div class="history-stats">
                        <div class="history-stat">
                            <span>Win Rate</span>
                            <span class="history-stat-value" id="accuracy-${analysis.timeframe}">0%</span>
                        </div>
                        <div class="history-stat">
                            <span>Retorno</span>
                            <span class="history-stat-value" id="returns-${analysis.timeframe}">0%</span>
                        </div>
                        <div class="history-stat">
                            <span>Trades</span>
                            <span class="history-stat-value" id="trades-${analysis.timeframe}">0</span>
                        </div>
                    </div>
                    <div class="button-group">
                        <button class="btn btn-primary" onclick="toggleHistory('${analysis.timeframe}')">
                            📊 Ver Histórico
                        </button>
                        <button class="btn btn-secondary" onclick="createTestTrade('${analysis.timeframe}')" style="font-size: 11px; padding: 8px 12px;">
                            🧪 Testar
                        </button>
                        <button class="btn btn-danger" onclick="clearHistory('${analysis.timeframe}')">
                            🗑️ Limpar
                        </button>
                        <button class="btn btn-primary" onclick="openBacktestModal('${analysis.timeframe}')" style="background: linear-gradient(135deg, var(--green), #00e676); flex: 2;">
                            📊 BACKTEST
                        </button>
                    </div>
                    <div id="history-${analysis.timeframe}" style="display: none; margin-top: 12px; max-height: 400px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: var(--accent) var(--bg-dark);"></div>
                </div>
            `;
            
            // Atualizar estatísticas do histórico
            updateHistoryStats(analysis.timeframe);
            
            return card;
        }
        
        function getIndicatorLabel(key, timeframe) {
            const labels = {
                rsi: 'RSI',
                macd: 'MACD',
                stochRsi: 'Stoch RSI',
                mfi: 'MFI',
                trend: 'Tendência',
                occ: 'OCC',
                stcCci: 'STC-CCI'
            };
            
            // Retornar apenas o label sem o peso (agora mostrado como badge)
            return labels[key] || key;
        }
        
        function updateExistingCard(card, analysis) {
            try {
                console.log(`Atualizando card ${analysis.timeframe}`);
                
                // Atualizar classe do card
                card.className = `indicator-card ${analysis.direction === 'COMPRA' ? 'bullish' : analysis.direction === 'VENDA' ? 'bearish' : ''}`;
                card.setAttribute('data-timeframe', analysis.timeframe);
                
                // 🧠 ATUALIZAR BADGE ADAPTATIVO
                const adaptiveMode = getAdaptiveMode(analysis.timeframe);
                const adaptiveThreshold = getAdaptiveThreshold(analysis.timeframe);
                
                // CORREÇÃO CRÍTICA: Remover TODOS os badges antigos do card INTEIRO
                const oldBadges = card.querySelectorAll('.adaptive-badge');
                if (oldBadges.length > 0) {
                    console.log(`  🗑️ Removendo ${oldBadges.length} badges antigos de ${analysis.timeframe}`);
                    oldBadges.forEach(b => b.remove());
                }
                
                const oldInfos = card.querySelectorAll('.adaptive-info');
                if (oldInfos.length > 0) {
                    console.log(`  🗑️ Removendo ${oldInfos.length} infos antigas de ${analysis.timeframe}`);
                    oldInfos.forEach(i => i.remove());
                }
                
                // Recriar HTML do header
                const header = card.querySelector('.timeframe-header');
                if (header) {
                    // Verificar se há pesos modificados
                    const adaptiveSystem = state.adaptiveSystem?.[analysis.timeframe];
                    const hasModifiedWeights = adaptiveSystem?.indicatorWeights 
                        ? Object.values(adaptiveSystem.indicatorWeights).some(w => w !== 1)
                        : false;
                    
                    // Verificar quantos trades validados existem (excluindo manuais)
                    const validatedTrades = (state.tradeHistory[analysis.timeframe] || []).filter(t => t.validated && !t.isManual).length;
                    const needsMoreTrades = validatedTrades === 0;
                    
                    // Sistema é considerado ativo se: modo diferente de normal OU threshold diferente de 10 OU pesos modificados OU tem pelo menos 1 trade validado
                    const isAdaptive = adaptiveMode !== 'normal' || adaptiveThreshold !== 10 || hasModifiedWeights || validatedTrades > 0;
                    
                    const adaptiveBadges = {
                        'conservative': { emoji: '🛡️', text: 'Modo Conservador', color: 'var(--orange)' },
                        'aggressive': { emoji: '🚀', text: 'Modo Agressivo', color: 'var(--green)' },
                        'inverse': { emoji: '🔄', text: 'Modo Inverso', color: 'var(--accent)' },
                        'normal': { emoji: '🧠', text: 'Ajuste Ativo', color: 'var(--accent)' }
                    };
                    
                    // Recriar HTML do header completamente
                    header.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div class="timeframe-title">${analysis.timeframe.toUpperCase()}</div>
                            <div style="font-size: 11px; color: var(--accent); font-weight: bold; background: rgba(240, 185, 11, 0.1); padding: 3px 8px; border-radius: 4px;">
                                Score: ${analysis.score > 0 ? '+' : ''}${analysis.score.toFixed(0)}
                            </div>
                            ${needsMoreTrades ? `
                                <span style="
                                    font-size: 10px; 
                                    padding: 3px 8px; 
                                    background: var(--bg-light); 
                                    color: var(--text-secondary); 
                                    border-radius: 8px;
                                    font-weight: bold;
                                    display: inline-block;
                                " title="Aguardando primeiro trade validado">
                                    ⏳ Aguardando dados
                                </span>
                            ` : isAdaptive ? `
                                <span class="adaptive-badge" style="
                                    font-size: 10px; 
                                    padding: 3px 8px; 
                                    background: ${adaptiveBadges[adaptiveMode].color}; 
                                    color: white; 
                                    border-radius: 8px;
                                    font-weight: bold;
                                    display: inline-block;
                                " title="Sistema adaptativo ativo (${validatedTrades} trade(s) analisado(s))">
                                    ${adaptiveBadges[adaptiveMode].emoji} ${adaptiveBadges[adaptiveMode].text}
                                </span>
                            ` : ''}
                        </div>
                        <span class="signal-badge ${analysis.direction === 'COMPRA' ? 'buy' : analysis.direction === 'VENDA' ? 'sell' : 'neutral'}">
                            ${analysis.direction}
                        </span>
                    `;
                    
                    // Adicionar APENAS 1 info div se modo não for normal
                    if (adaptiveMode !== 'normal') {
                        const infoDiv = document.createElement('div');
                        infoDiv.className = 'adaptive-info';
                        infoDiv.style.cssText = `
                            font-size: 10px; 
                            color: ${adaptiveBadges[adaptiveMode].color}; 
                            margin-bottom: 8px; 
                            padding: 6px; 
                            background: rgba(255,255,255,0.05); 
                            border-radius: 4px;
                        `;
                        infoDiv.textContent = `🧠 Threshold adaptativo: ${adaptiveThreshold}% | Sistema ajustando baseado em ${adaptiveMode === 'inverse' ? 'mercado lateral' : 'performance recente'}`;
                        header.after(infoDiv);
                    }
                }
                
                // Não precisa mais atualizar signalBadge pois já foi feito no innerHTML acima
                
                // Atualizar barras de indicadores
                Object.entries(analysis.indicators).forEach(([key, data]) => {
                    const normalizedScore = Math.max(-100, Math.min(100, data.score));
                    const percentage = normalizedScore;
                    const barPercentage = 50 + (percentage / 2);
                    
                    // Atualizar o indicador
                    const indicatorItem = card.querySelector(`[data-indicator="${key}"]`);
                    if (indicatorItem) {
                        // Atualizar o texto de porcentagem
                        const percentEl = indicatorItem.querySelector('.indicator-percent');
                        if (percentEl) {
                            percentEl.textContent = `${percentage > 0 ? '+' : ''}${percentage.toFixed(0)}%`;
                            percentEl.style.color = percentage > 25 ? 'var(--green)' : percentage < -25 ? 'var(--red)' : 'var(--text-secondary)';
                        }
                        
                        // Atualizar a barra de preenchimento
                        const barContainer = indicatorItem.querySelector('.indicator-bar-container');
                        if (barContainer) {
                            const fillBar = barContainer.children[1]; // Barra de preenchimento é o segundo filho
                            const positionIndicator = barContainer.children[2]; // Indicador de posição é o terceiro filho
                            
                            if (fillBar) {
                                fillBar.style.width = `${barPercentage}%`;
                                fillBar.style.background = percentage > 0 ? 'rgba(2, 192, 118, 0.3)' : 'rgba(248, 73, 96, 0.3)';
                            }
                            
                            if (positionIndicator) {
                                positionIndicator.style.left = `${barPercentage}%`;
                                const indicatorColor = percentage > 25 ? 'var(--green)' : percentage < -25 ? 'var(--red)' : 'var(--accent)';
                                positionIndicator.style.backgroundColor = indicatorColor;
                                positionIndicator.style.boxShadow = `0 0 8px ${indicatorColor}`;
                            }
                        }
                    }
                });
                
                // Atualizar média geral
                const avgScore = Object.values(analysis.indicators).reduce((sum, ind) => sum + ind.score, 0) / Object.keys(analysis.indicators).length;
                const normalizedAvg = Math.max(-100, Math.min(100, avgScore));
                const avgBarPercentage = 50 + (normalizedAvg / 2);
                
                const avgItem = card.querySelector('[data-indicator="average"]');
                if (avgItem) {
                    const avgPercentEl = avgItem.querySelector('.indicator-percent');
                    if (avgPercentEl) {
                        avgPercentEl.textContent = `${normalizedAvg > 0 ? '+' : ''}${normalizedAvg.toFixed(0)}%`;
                    }
                    
                    // Atualizar a barra da média geral
                    const avgBarContainer = avgItem.querySelector('.indicator-bar-container');
                    if (avgBarContainer) {
                        const avgFillBar = avgBarContainer.children[1];
                        const avgPositionIndicator = avgBarContainer.children[2];
                        
                        if (avgFillBar) {
                            avgFillBar.style.width = `${avgBarPercentage}%`;
                            avgFillBar.style.background = normalizedAvg > 0 ? 'rgba(2, 192, 118, 0.4)' : 'rgba(248, 73, 96, 0.4)';
                        }
                        
                        if (avgPositionIndicator) {
                            avgPositionIndicator.style.left = `${avgBarPercentage}%`;
                        }
                    }
                }
                
                // Atualizar preços de entrada, TP e SL
                const entryEl = card.querySelector('[data-price="entry"]');
                if (entryEl) entryEl.textContent = `$${analysis.currentPrice.toFixed(5)}`;
                
                const tpEl = card.querySelector('[data-price="tp"]');
                if (tpEl) {
                    const tp = analysis.direction === 'COMPRA' ? 
                        analysis.currentPrice + (3 * analysis.atr) : 
                        analysis.currentPrice - (3 * analysis.atr);
                    tpEl.textContent = `$${tp.toFixed(5)}`;
                }
                
                const slEl = card.querySelector('[data-price="sl"]');
                if (slEl) {
                    const sl = analysis.direction === 'COMPRA' ? 
                        analysis.currentPrice - (1.5 * analysis.atr) : 
                        analysis.currentPrice + (1.5 * analysis.atr);
                    slEl.textContent = `$${sl.toFixed(5)}`;
                }
                
                // Atualizar estatísticas
                updateHistoryStats(analysis.timeframe);
                
                console.log(`Card ${analysis.timeframe} atualizado com sucesso`);
                
            } catch (error) {
                console.error(`Erro ao atualizar card ${analysis.timeframe}:`, error);
                console.error('Stack:', error.stack);
                // Se der erro, recriar o card
                try {
                    const gridContainer = card.parentElement;
                    const newCard = createIndicatorCard(analysis);
                    gridContainer.replaceChild(newCard, card);
                    console.log(`Card ${analysis.timeframe} recriado após erro`);
                } catch (recreateError) {
                    console.error(`Erro ao recriar card ${analysis.timeframe}:`, recreateError);
                }
            }
        }
        
        // ============================================
        // NOTIFICAÇÃO SONORA
        // ============================================
        function playSignalSound() {
            try {
                // Criar um contexto de áudio
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                // Configurar o som (tom de notificação agradável)
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800; // Frequência em Hz
                oscillator.type = 'sine'; // Tipo de onda
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime); // Volume
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3); // Duração de 0.3s
            } catch (error) {
                console.warn('Não foi possível reproduzir som:', error);
            }
        }
        
        // ============================================
        // NOTIFICAÇÃO SONORA
        // ============================================
        function playSignalSound() {
            try {
                // Criar um contexto de áudio
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                // Configurar o som (tom de notificação agradável)
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800; // Frequência em Hz
                oscillator.type = 'sine'; // Tipo de onda
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime); // Volume
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3); // Duração de 0.3s
            } catch (error) {
                console.warn('Não foi possível reproduzir som:', error);
            }
        }
        
        // ============================================
        // GESTÃO DE HISTÓRICO E VALIDAÇÃO DE TRADES
        // ============================================
        function trackTrade(timeframe, analysis) {
            if (!state.tradeHistory[timeframe]) {
                state.tradeHistory[timeframe] = [];
            }
            
            const history = state.tradeHistory[timeframe];
            
            // Se for trade manual, processar diretamente sem threshold adaptativo
            if (analysis.isManual) {
                const entryPrice = analysis.currentPrice;
                const timestamp = Date.now();
                const prediction = analysis.direction; // Já vem como 'COMPRA' ou 'VENDA'
                
                console.log(`🎯 Trade MANUAL registrado: ${timeframe} ${prediction} @ $${entryPrice.toFixed(2)}`);
                
                // Calcular TP e SL
                const takeProfit = prediction === 'COMPRA' ? 
                    entryPrice + (3 * analysis.atr) : 
                    entryPrice - (3 * analysis.atr);
                    
                const stopLoss = prediction === 'COMPRA' ? 
                    entryPrice - (1.5 * analysis.atr) : 
                    entryPrice + (1.5 * analysis.atr);
                
                // Calcular média correta dos indicadores
                const avgScore = Object.values(analysis.indicators).reduce((sum, ind) => sum + ind.score, 0) / Object.keys(analysis.indicators).length;
                const normalizedAvg = Math.max(-100, Math.min(100, avgScore));
                
                history.push({
                    prediction,
                    entryPrice,
                    takeProfit,
                    stopLoss,
                    timestamp,
                    avgIndicatorScore: normalizedAvg,
                    validated: false,
                    endPrice: null,
                    result: null,
                    success: null,
                    isManual: true // Marcar como manual para não afetar aprendizado
                });
                
                // Limitar histórico a 100 trades
                if (history.length > 100) history.shift();
                
                state.tradeHistory[timeframe] = history;
                saveToLocalStorage(`tradeHistory_${config.symbol}`, state.tradeHistory);
                
                // Incrementar contador de sinais
                state.sessionStats.signalsToday++;
                
                // 🔔 Tocar som de notificação
                playSignalSound();
                
                return;
            }
            
            // Usar score TOTAL para comparação com threshold (soma de todos os indicadores)
            const totalScore = analysis.score;
            
            // Calcular média para exibição (força do sinal)
            const avgScore = Object.values(analysis.indicators).reduce((sum, ind) => sum + ind.score, 0) / Object.keys(analysis.indicators).length;
            const normalizedAvg = Math.max(-100, Math.min(100, avgScore));
            
            // 🧠 THRESHOLD ADAPTATIVO: Varia de 5% a 25% baseado em performance
            const adaptiveThreshold = getAdaptiveThreshold(timeframe);
            const adaptiveMode = getAdaptiveMode(timeframe);
            
            console.log(`🔍 ${timeframe}: Score = ${totalScore.toFixed(1)} | Média = ${normalizedAvg.toFixed(1)}% | Min usuário = ${config.minSignalStrength} | Threshold adaptativo = ${adaptiveThreshold}`);
            
            // Verificar força mínima configurada pelo usuário (usa SCORE TOTAL)
            if (Math.abs(totalScore) < config.minSignalStrength) {
                console.log(`❌ ${timeframe}: Sinal BLOQUEADO - score ${Math.abs(totalScore).toFixed(0)} abaixo do mínimo do usuário (${config.minSignalStrength})`);
                return;
            }
            
            // Só rastrear se tiver um sinal definido (não neutro) E acima do threshold adaptativo
            if (Math.abs(totalScore) < adaptiveThreshold) {
                console.log(`❌ ${timeframe}: Sinal BLOQUEADO - score ${Math.abs(totalScore).toFixed(0)} abaixo do threshold adaptativo (${adaptiveThreshold})`);
                return;
            }
            
            if (Math.abs(totalScore) > 0) {
                let prediction = totalScore > 0 ? 'COMPRA' : 'VENDA';
                
                // 🔄 MODO INVERSE: Se mercado lateral, inverter sinais
                if (adaptiveMode === 'inverse') {
                    prediction = prediction === 'COMPRA' ? 'VENDA' : 'COMPRA';
                    console.log(`🔄 ${timeframe}: Modo INVERSE ativo! Sinal invertido para ${prediction}`);
                }
                
                const entryPrice = analysis.currentPrice;
                const timestamp = Date.now();
                
                console.log(`🎯 Sinal detectado: ${timeframe} ${prediction} @ $${entryPrice.toFixed(2)} | Score: ${totalScore.toFixed(0)} | Média: ${normalizedAvg.toFixed(0)}% | Threshold: ${adaptiveThreshold} | Modo: ${adaptiveMode}`);
                
                // Calcular TP e SL
                const takeProfit = prediction === 'COMPRA' ? 
                    entryPrice + (3 * analysis.atr) : 
                    entryPrice - (3 * analysis.atr);
                    
                const stopLoss = prediction === 'COMPRA' ? 
                    entryPrice - (1.5 * analysis.atr) : 
                    entryPrice + (1.5 * analysis.atr);
                
                // Verificar se já existe um trade recente não validado
                const lastTrade = history[history.length - 1];
                const timeframeMs = convertTimeframeToMs(timeframe);
                
                // Só adicionar novo trade se não houver trade pendente recente
                if (!lastTrade || lastTrade.validated || (timestamp - lastTrade.timestamp) >= timeframeMs) {
                    history.push({
                        prediction,
                        entryPrice,
                        takeProfit,
                        stopLoss,
                        timestamp,
                        avgIndicatorScore: normalizedAvg,
                        indicators: analysis.indicators, // 🎯 Salvar indicadores para análise posterior
                        validated: false,
                        endPrice: null,
                        result: null,
                        success: null,
                        isManual: false // 🎯 Marcar explicitamente como trade automático
                    });
                    
                    // Limitar histórico a 100 trades
                    if (history.length > 100) history.shift();
                    
                    state.tradeHistory[timeframe] = history;
                    saveToLocalStorage(`tradeHistory_${config.symbol}`, state.tradeHistory);
                    
                    // Incrementar contador de sinais
                    state.sessionStats.signalsToday++;
                    
                    // 🔔 Tocar som de notificação
                    playSignalSound();
                }
            }
        }
        
        function validateTrades(currentPrice) {
            let hasUpdates = false;
            
            Object.keys(state.tradeHistory).forEach(timeframe => {
                const history = state.tradeHistory[timeframe] || [];
                const timeframeMs = convertTimeframeToMs(timeframe);
                
                history.forEach(trade => {
                    // Validar apenas trades pendentes que já passaram do tempo
                    if (!trade.validated && (Date.now() - trade.timestamp) >= timeframeMs) {
                        trade.validated = true;
                        trade.endPrice = currentPrice;
                        
                        // Calcular resultado
                        const priceChange = ((trade.endPrice - trade.entryPrice) / trade.entryPrice) * 100;
                        
                        // Verificar se acertou baseado em TP/SL
                        if (trade.prediction === 'COMPRA') {
                            if (trade.endPrice >= trade.takeProfit) {
                                trade.result = 'TP_HIT';
                                trade.success = true;
                            } else if (trade.endPrice <= trade.stopLoss) {
                                trade.result = 'SL_HIT';
                                trade.success = false;
                            } else {
                                // Não atingiu nem TP nem SL, verificar se teve lucro
                                trade.result = trade.endPrice > trade.entryPrice ? 'PROFIT' : 'LOSS';
                                trade.success = trade.endPrice > trade.entryPrice;
                            }
                        } else { // VENDA
                            if (trade.endPrice <= trade.takeProfit) {
                                trade.result = 'TP_HIT';
                                trade.success = true;
                            } else if (trade.endPrice >= trade.stopLoss) {
                                trade.result = 'SL_HIT';
                                trade.success = false;
                            } else {
                                trade.result = trade.endPrice < trade.entryPrice ? 'PROFIT' : 'LOSS';
                                trade.success = trade.endPrice < trade.entryPrice;
                            }
                        }
                        
                        trade.priceChange = priceChange;
                        
                        // CORREÇÃO: Calcular retorno REAL baseado se acertou a direção
                        // Se COMPRA e preço subiu (+2%) = +2% de retorno
                        // Se COMPRA e preço caiu (-2%) = -2% de retorno  
                        // Se VENDA e preço caiu (-2%) = +2% de retorno (acertou!)
                        // Se VENDA e preço subiu (+2%) = -2% de retorno (errou!)
                        
                        let realReturn = 0;
                        if (trade.prediction === 'COMPRA') {
                            realReturn = priceChange; // Se comprou, ganho = variação
                        } else { // VENDA
                            realReturn = -priceChange; // Se vendeu, ganho = inverso da variação
                        }
                        
                        trade.baseReturn = realReturn; // Guardar retorno sem alavancagem
                        trade.realReturn = realReturn * config.leverage;
                        trade.profitWithLeverage = realReturn * config.leverage; // Manter compatibilidade
                        
                        hasUpdates = true;
                    }
                });
            });
            
            if (hasUpdates) {
                saveToLocalStorage(`tradeHistory_${config.symbol}`, state.tradeHistory);
                updateOverallStats();
                
                // 🧠 ATUALIZAR SISTEMA ADAPTATIVO após validação de trades
                Object.keys(state.tradeHistory).forEach(tf => {
                    updateAdaptiveSystem(tf);
                });
            }
        }
        
        function convertTimeframeToMs(timeframe) {
            const value = parseInt(timeframe);
            if (timeframe.includes('h')) return value * 60 * 60 * 1000;
            return value * 60 * 1000; // minutos
        }
        
        function updateOpenHistories() {
            // Atualizar APENAS os históricos que estão abertos, sem afetar os cards
            ['1m', '5m', '15m', '1h'].forEach(tf => {
                const historyDiv = document.getElementById(`history-${tf}`);
                // Só atualizar se o histórico estiver visível
                if (historyDiv && historyDiv.style.display === 'block') {
                    renderTradeHistory(tf, historyDiv);
                }
            });
        }
        
        function updateHistoryStats(timeframe) {
            try {
                const history = state.tradeHistory[timeframe] || [];
                const validated = history.filter(t => t.validated);
                
                const accuracyEl = document.getElementById(`accuracy-${timeframe}`);
                const returnsEl = document.getElementById(`returns-${timeframe}`);
                const tradesEl = document.getElementById(`trades-${timeframe}`);
                
                if (!accuracyEl || !returnsEl || !tradesEl) {
                    console.warn(`Elementos de estatísticas não encontrados para ${timeframe}`);
                    return;
                }
                
                if (validated.length > 0) {
                    const winRate = (validated.filter(t => t.success).length / validated.length * 100).toFixed(0);
                    
                    // CORREÇÃO: Usar realReturn que já considera a direção correta
                    const returns = validated.reduce((sum, t) => {
                        return sum + (t.realReturn || 0);
                    }, 0);
                    
                    accuracyEl.textContent = `${winRate}%`;
                    returnsEl.textContent = `${returns > 0 ? '+' : ''}${returns.toFixed(2)}%`;
                    returnsEl.style.color = returns > 0 ? 'var(--green)' : 'var(--red)';
                    tradesEl.textContent = validated.length;
                } else {
                    accuracyEl.textContent = '0%';
                    returnsEl.textContent = '0%';
                    returnsEl.style.color = 'var(--text-secondary)';
                    tradesEl.textContent = '0';
                }
            } catch (error) {
                console.error(`Erro ao atualizar estatísticas ${timeframe}:`, error);
            }
        }
        
        function updateOverallStats() {
            const allTrades = Object.values(state.tradeHistory).flat().filter(t => t.validated);
            
            if (allTrades.length > 0) {
                const wins = allTrades.filter(t => t.success).length;
                const winRate = (wins / allTrades.length * 100).toFixed(0);
                document.getElementById('overall-winrate').textContent = `${winRate}%`;
                
                // CORREÇÃO: Usar realReturn que já considera direção
                const returns = allTrades.reduce((sum, t) => {
                    return sum + (t.realReturn || 0);
                }, 0);
                
                const returnsEl = document.getElementById('overall-returns');
                returnsEl.textContent = `${returns > 0 ? '+' : ''}${returns.toFixed(2)}%`;
                returnsEl.style.color = returns > 0 ? 'var(--green)' : 'var(--red)';
                
                // Atualizar contadores: Total de sinais validados e Acertos
                document.getElementById('signals-today').textContent = allTrades.length;
                document.getElementById('signals-trend').textContent = `${wins} confirmados`;
            } else {
                document.getElementById('signals-today').textContent = '0';
                document.getElementById('signals-trend').textContent = '0 confirmados';
            }
            
            // Atualizar sidebar de sinais
            updateSignalsSidebar();
            
            // Melhor timeframe
            const tfStats = {};
            ['1m', '5m', '15m', '1h'].forEach(tf => {
                const trades = (state.tradeHistory[tf] || []).filter(t => t.validated);
                if (trades.length > 0) {
                    const wins = trades.filter(t => t.success).length;
                    tfStats[tf] = {
                        winRate: (wins / trades.length * 100),
                        total: trades.length
                    };
                }
            });
            
            const bestTfEl = document.getElementById('best-timeframe');
            const bestTfAccEl = document.getElementById('best-tf-accuracy');
            
            if (Object.keys(tfStats).length > 0) {
                const best = Object.entries(tfStats).sort((a, b) => b[1].winRate - a[1].winRate)[0];
                if (bestTfEl) bestTfEl.textContent = best[0].toUpperCase();
                if (bestTfAccEl) bestTfAccEl.textContent = `${best[1].winRate.toFixed(0)}% acurácia`;
            } else {
                if (bestTfEl) bestTfEl.textContent = '-';
                if (bestTfAccEl) bestTfAccEl.textContent = 'Aguardando dados';
            }
            
            // 🧠 Atualizar card do Sistema Adaptativo
            updateAdaptiveStatusCard();
        }
        
        function updateAdaptiveStatusCard() {
            const statusEl = document.getElementById('adaptive-status');
            const infoEl = document.getElementById('adaptive-info');
            
            if (!statusEl || !infoEl) return;
            
            // Contar quantos timeframes estão em modo adaptativo
            const modes = Object.values(state.adaptiveSystem).map(s => s.mode);
            const activeAdaptive = modes.filter(m => m !== 'normal').length;
            
            // Calcular quantas análises até próxima verificação
            const untilNext = 10 - (state.adaptiveCheckCounter || 0);
            
            if (activeAdaptive === 0) {
                statusEl.textContent = 'MODO NORMAL';
                infoEl.textContent = `Todos OK • Próxima verificação: ${untilNext} análises`;
            } else {
                statusEl.textContent = `${activeAdaptive}/4 AJUSTADOS`;
                
                const modeCount = {};
                modes.forEach(m => {
                    if (m !== 'normal') {
                        modeCount[m] = (modeCount[m] || 0) + 1;
                    }
                });
                
                const modeTexts = {
                    'conservative': '🛡️',
                    'aggressive': '🚀',
                    'inverse': '🔄'
                };
                
                const info = Object.entries(modeCount)
                    .map(([mode, count]) => `${count}${modeTexts[mode]}`)
                    .join(' ');
                    
                infoEl.textContent = `${info} • Verificando a cada 10 análises`;
            }
        }
        
        function toggleHistory(timeframe) {
            const historyDiv = document.getElementById(`history-${timeframe}`);
            if (!historyDiv) {
                console.error(`❌ Elemento history-${timeframe} não encontrado!`);
                return;
            }
            
            historyDiv.style.display = historyDiv.style.display === 'none' ? 'block' : 'none';
            
            if (historyDiv.style.display === 'block') {
                console.log(`📊 Abrindo histórico ${timeframe}:`, state.tradeHistory[timeframe]);
                renderTradeHistory(timeframe, historyDiv);
            }
        }
        
        function renderTradeHistory(timeframe, container) {
            // Garantir que o histórico existe
            if (!state.tradeHistory[timeframe]) {
                state.tradeHistory[timeframe] = [];
            }
            
            const history = (state.tradeHistory[timeframe] || []).slice(-20).reverse();
            
            console.log(`📝 Renderizando histórico ${timeframe}: ${history.length} trades`);
            
            if (history.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 30px; color: var(--text-secondary); background-color: var(--bg-dark); border-radius: 8px;">
                        <div style="font-size: 32px; margin-bottom: 10px;">📊</div>
                        <div>Nenhum histórico disponível</div>
                        <div style="font-size: 11px; margin-top: 5px;">Os sinais aparecerão aqui automaticamente</div>
                        <div style="font-size: 10px; margin-top: 10px; color: var(--accent);">
                            Aguardando sinais com score >= <span class="score-threshold-display">${config.minSignalStrength}</span>%
                        </div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = history.map((trade, index) => {
                const isValidated = trade.validated;
                const isPending = !isValidated;
                
                // Calcular tempo restante para validação
                let timeRemaining = '';
                if (isPending) {
                    const timeframeMs = convertTimeframeToMs(timeframe);
                    const elapsed = Date.now() - trade.timestamp;
                    const remaining = Math.max(0, timeframeMs - elapsed);
                    const remainingSeconds = Math.floor(remaining / 1000);
                    const remainingMinutes = Math.floor(remainingSeconds / 60);
                    
                    if (remainingMinutes > 0) {
                        timeRemaining = `${remainingMinutes}m ${remainingSeconds % 60}s`;
                    } else {
                        timeRemaining = `${remainingSeconds}s`;
                    }
                }
                
                // Definir cores e ícones
                const signalColor = trade.prediction === 'COMPRA' ? 'var(--green)' : 'var(--red)';
                const resultColor = isPending ? 'var(--accent)' : (trade.success ? 'var(--green)' : 'var(--red)');
                const resultIcon = isPending ? '⏳' : (trade.success ? '✅' : '❌');
                const resultText = isPending ? `Aguardando ${timeRemaining}` : 
                    (trade.result === 'TP_HIT' ? 'ACERTOU (TP)' : 
                     trade.result === 'SL_HIT' ? 'ERROU (SL)' : 
                     trade.success ? 'ACERTOU' : 'ERROU');
                
                return `
                    <div style="
                        padding: 14px;
                        margin: 10px 0;
                        background: linear-gradient(135deg, var(--bg-dark), var(--bg-medium));
                        border-radius: 8px;
                        border-left: 4px solid ${resultColor};
                        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    ">
                        <!-- Header com data e resultado -->
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                ${new Date(trade.timestamp).toLocaleString('pt-BR', { 
                                    day: '2-digit', 
                                    month: '2-digit', 
                                    hour: '2-digit', 
                                    minute: '2-digit' 
                                })}
                            </div>
                            <div style="
                                display: flex;
                                align-items: center;
                                gap: 6px;
                                font-weight: bold;
                                font-size: 13px;
                                color: ${resultColor};
                            ">
                                <span>${resultIcon}</span>
                                <span>${resultText}</span>
                            </div>
                        </div>
                        
                        <!-- Sinal -->
                        <div style="
                            background-color: ${trade.prediction === 'COMPRA' ? 'var(--green-bg)' : 'var(--red-bg)'};
                            padding: 10px;
                            border-radius: 6px;
                            margin-bottom: 10px;
                            border: 1px solid ${signalColor};
                        ">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <span style="font-size: 11px; color: var(--text-secondary);">
                                        ${trade.isManual ? '🎯 Trade Manual:' : 'Sinal:'}
                                    </span>
                                    <strong style="color: ${signalColor}; font-size: 14px; margin-left: 6px;">
                                        ${trade.prediction === 'COMPRA' ? '🟢 COMPRA' : '🔴 VENDA'}
                                    </strong>
                                    ${trade.isManual ? '<span style="font-size: 10px; color: var(--accent); margin-left: 8px; background: rgba(240, 185, 11, 0.1); padding: 2px 6px; border-radius: 4px;">MANUAL</span>' : ''}
                                </div>
                                <div style="font-size: 11px; color: var(--text-secondary);">
                                    Força: <strong style="color: ${signalColor};">${Math.abs(trade.avgIndicatorScore).toFixed(0)}%</strong>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Entrada -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px; margin-bottom: 8px;">
                            <div>
                                <div style="color: var(--text-secondary); font-size: 10px;">Entrada</div>
                                <div style="font-weight: bold; color: var(--accent);">$${trade.entryPrice.toFixed(5)}</div>
                            </div>
                            ${isValidated ? `
                                <div>
                                    <div style="color: var(--text-secondary); font-size: 10px;">Saída</div>
                                    <div style="font-weight: bold; color: ${resultColor};">$${trade.endPrice.toFixed(5)}</div>
                                </div>
                            ` : `
                                <div>
                                    <div style="color: var(--text-secondary); font-size: 10px;">Atual</div>
                                    <div style="font-weight: bold; color: var(--accent);">$${state.currentPrice.toFixed(5)}</div>
                                </div>
                            `}
                        </div>
                        
                        ${isPending ? (() => {
                            const currentVariation = ((state.currentPrice - trade.entryPrice) / trade.entryPrice) * 100;
                            const variationColor = currentVariation >= 0 ? 'var(--green)' : 'var(--red)';
                            
                            // Calcular variação considerando a direção do trade
                            let realVariation = currentVariation;
                            if (trade.prediction === 'VENDA') {
                                realVariation = -currentVariation; // Inverter para vendas
                            }
                            
                            return `
                                <div style="
                                    margin-bottom: 8px;
                                    padding: 6px 8px;
                                    background: rgba(255,255,255,0.05);
                                    border-radius: 4px;
                                    border-left: 3px solid ${realVariation >= 0 ? 'var(--green)' : 'var(--red)'};
                                ">
                                    <div style="display: flex; justify-content: space-between; align-items: center; font-size: 11px;">
                                        <span style="color: var(--text-secondary);">Variação em tempo real:</span>
                                        <strong style="color: ${realVariation >= 0 ? 'var(--green)' : 'var(--red)'};">
                                            ${realVariation >= 0 ? '+' : ''}${realVariation.toFixed(2)}%
                                        </strong>
                                    </div>
                                </div>
                            `;
                        })() : ''}
                        
                        <!-- Take Profit e Stop Loss -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">
                            <div style="
                                padding: 6px;
                                background-color: var(--green-bg);
                                border-radius: 4px;
                                border: 1px solid var(--green);
                            ">
                                <div style="color: var(--text-secondary); font-size: 9px;">Take Profit</div>
                                <div style="font-weight: bold; color: var(--green);">$${trade.takeProfit.toFixed(5)}</div>
                            </div>
                            <div style="
                                padding: 6px;
                                background-color: var(--red-bg);
                                border-radius: 4px;
                                border: 1px solid var(--red);
                            ">
                                <div style="color: var(--text-secondary); font-size: 9px;">Stop Loss</div>
                                <div style="font-weight: bold; color: var(--red);">$${trade.stopLoss.toFixed(5)}</div>
                            </div>
                        </div>
                        
                        <!-- Resultado (apenas se validado) -->
                        ${isValidated ? `
                            <div style="
                                margin-top: 10px;
                                padding: 8px;
                                background-color: ${trade.success ? 'var(--green-bg)' : 'var(--red-bg)'};
                                border-radius: 6px;
                                border: 1px solid ${trade.success ? 'var(--green)' : 'var(--red)'};
                            ">
                                <div style="display: flex; justify-content: space-between; font-size: 12px;">
                                    <div>
                                        <span style="color: var(--text-secondary);">Preço variou:</span>
                                        <strong style="color: ${trade.priceChange >= 0 ? 'var(--green)' : 'var(--red)'}; margin-left: 6px;">
                                            ${trade.priceChange >= 0 ? '+' : ''}${trade.priceChange.toFixed(2)}%
                                        </strong>
                                    </div>
                                    <div>
                                        <span style="color: var(--text-secondary);">Seu retorno ${config.leverage}x:</span>
                                        <strong style="color: ${(trade.realReturn || trade.profitWithLeverage) >= 0 ? 'var(--green)' : 'var(--red)'}; margin-left: 6px; font-size: 13px;">
                                            ${(trade.realReturn || trade.profitWithLeverage) >= 0 ? '+' : ''}${(trade.realReturn || trade.profitWithLeverage).toFixed(2)}%
                                        </strong>
                                    </div>
                                </div>
                            </div>
                            
                            ${trade.indicators && !trade.isManual ? (() => {
                                const priceVariation = Math.abs(((trade.endPrice - trade.entryPrice) / trade.entryPrice) * 100);
                                
                                // Determinar ajuste baseado na variação
                                let weightAdjustment = 0;
                                if (priceVariation < 0.1) {
                                    return ''; // Não mostra nada se variação muito pequena
                                } else if (priceVariation >= 0.1 && priceVariation < 1.0) {
                                    weightAdjustment = 0.1;
                                } else if (priceVariation >= 1.0 && priceVariation < 5.0) {
                                    weightAdjustment = 0.2;
                                } else {
                                    weightAdjustment = 0.3;
                                }
                                
                                const indicatorResults = Object.entries(trade.indicators).map(([key, indicator]) => {
                                    const indicatorAgreed = (trade.prediction === 'COMPRA' && indicator.score > 0) || 
                                                           (trade.prediction === 'VENDA' && indicator.score < 0);
                                    
                                    const indicatorNames = {
                                        rsi: 'RSI',
                                        macd: 'MACD',
                                        stochRsi: 'Stoch RSI',
                                        mfi: 'MFI',
                                        trend: 'Tendência'
                                    };
                                    
                                    if (!indicatorAgreed) {
                                        return null; // Ignorar indicadores que discordaram
                                    }
                                    
                                    const wasCorrect = trade.success;
                                    const adjustment = wasCorrect ? `+${weightAdjustment.toFixed(1)}x` : `-${weightAdjustment.toFixed(1)}x`;
                                    const adjustmentColor = wasCorrect ? 'var(--green)' : 'var(--red)';
                                    const icon = wasCorrect ? '✅' : '❌';
                                    
                                    return {
                                        name: indicatorNames[key] || key,
                                        wasCorrect,
                                        adjustment,
                                        adjustmentColor,
                                        icon
                                    };
                                }).filter(r => r !== null);
                                
                                if (indicatorResults.length === 0) return '';
                                
                                return `
                                    <div style="
                                        margin-top: 8px;
                                        padding: 8px;
                                        background: rgba(0,0,0,0.2);
                                        border-radius: 6px;
                                        border: 1px solid rgba(255,255,255,0.1);
                                    ">
                                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 6px; font-weight: bold;">
                                            🧠 AJUSTES DO SISTEMA ADAPTATIVO:
                                        </div>
                                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; font-size: 10px;">
                                            ${indicatorResults.map(r => `
                                                <div style="
                                                    display: flex;
                                                    align-items: center;
                                                    justify-content: space-between;
                                                    padding: 4px 6px;
                                                    background: rgba(255,255,255,0.03);
                                                    border-radius: 4px;
                                                ">
                                                    <span style="color: var(--text-secondary);">
                                                        ${r.icon} ${r.name}
                                                    </span>
                                                    <span style="color: ${r.adjustmentColor}; font-weight: bold;">
                                                        ${r.adjustment}
                                                    </span>
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                `;
                            })() : ''}
                        ` : ''}
                    </div>
                `;
            }).join('');
        }
        
        function clearHistory(timeframe) {
            if (confirm(`Confirma limpar o histórico do timeframe ${timeframe}?\n\n⚠️ Isso também resetará o sistema adaptativo deste timeframe.`)) {
                console.log(`🗑️ Limpando histórico ${timeframe}...`);
                
                // Limpar histórico
                state.tradeHistory[timeframe] = [];
                saveToLocalStorage(`tradeHistory_${config.symbol}`, state.tradeHistory);
                
                // 🔄 RESETAR SISTEMA ADAPTATIVO deste timeframe
                console.log(`🔄 Resetando sistema adaptativo de ${timeframe}...`);
                resetAdaptiveSystem(timeframe);
                
                // 🗑️ FORÇAR REMOÇÃO DE BADGES do card
                const card = document.querySelector(`[data-timeframe="${timeframe}"]`);
                if (card) {
                    console.log(`🗑️ Removendo badges do card ${timeframe}...`);
                    
                    // Remover TODOS os badges e infos
                    const badges = card.querySelectorAll('.adaptive-badge');
                    const infos = card.querySelectorAll('.adaptive-info');
                    
                    badges.forEach(b => {
                        console.log(`  Removendo badge:`, b.textContent);
                        b.remove();
                    });
                    
                    infos.forEach(i => {
                        console.log(`  Removendo info:`, i.textContent);
                        i.remove();
                    });
                    
                    console.log(`✅ ${badges.length} badges e ${infos.length} infos removidos`);
                }
                
                // Atualizar estatísticas
                updateHistoryStats(timeframe);
                
                // Se o histórico está aberto, atualizar visual
                const historyDiv = document.getElementById(`history-${timeframe}`);
                if (historyDiv && historyDiv.style.display === 'block') {
                    console.log(`📝 Atualizando visual do histórico ${timeframe}`);
                    renderTradeHistory(timeframe, historyDiv);
                }
                
                // Atualizar card adaptativo
                updateAdaptiveStatusCard();
                
                console.log(`✅ Histórico ${timeframe} limpo e sistema adaptativo resetado!`);
                showNotification('Histórico Limpo', `${timeframe.toUpperCase()} resetado • Sistema adaptativo restaurado`, 'success', 4000);
            }
        }
        
        // RESETAR PESOS DOS INDICADORES
        function resetIndicatorWeights(timeframe) {
            console.log(`🔄 Tentando resetar pesos para timeframe:`, timeframe);
            console.log(`🔍 Tipo de timeframe:`, typeof timeframe);
            console.log(`🔍 State adaptiveSystem:`, state.adaptiveSystem);
            
            if (!timeframe) {
                console.error(`❌ Timeframe está undefined ou vazio`);
                showNotification(
                    '❌ Erro',
                    `Timeframe não foi fornecido`,
                    'error',
                    3000
                );
                return;
            }
            
            if (!state.adaptiveSystem) {
                console.error(`❌ state.adaptiveSystem não existe`);
                return;
            }
            
            if (!state.adaptiveSystem[timeframe]) {
                console.error(`❌ Sistema adaptativo não existe para ${timeframe}`);
                console.error(`❌ Timeframes disponíveis:`, Object.keys(state.adaptiveSystem));
                showNotification(
                    '❌ Erro',
                    `Sistema adaptativo não encontrado para ${timeframe}`,
                    'error',
                    3000
                );
                return;
            }
            
            // Resetar todos os pesos para 1.0
            const adaptive = state.adaptiveSystem[timeframe];
            if (!adaptive.indicatorWeights) {
                console.error(`❌ indicatorWeights não existe para ${timeframe}`);
                showNotification(
                    '❌ Erro',
                    `Pesos dos indicadores não encontrados`,
                    'error',
                    3000
                );
                return;
            }
            
            console.log(`✅ Resetando pesos:`, adaptive.indicatorWeights);
            Object.keys(adaptive.indicatorWeights).forEach(key => {
                adaptive.indicatorWeights[key] = 1.0;
            });
            
            // Salvar no localStorage
            saveToLocalStorage(`adaptiveSystem_${config.symbol}`, state.adaptiveSystem);
            
            console.log(`🔄 ${timeframe}: Todos os pesos resetados para 1.0x`);
            
            // Usar a função padronizada para atualizar badges
            updateCardWeightBadges(timeframe);
            
            showNotification(
                '🔄 Pesos Resetados',
                `${timeframe.toUpperCase()}: Todos os indicadores voltaram para 1.0x`,
                'info',
                3000
            );
        }
        
        // FUNÇÃO DE TESTE: Criar trade de exemplo
        function createTestTrade(timeframe) {
            console.log(`🧪 Criando trade de teste para ${timeframe}...`);
            
            if (!state.tradeHistory[timeframe]) {
                state.tradeHistory[timeframe] = [];
            }
            
            const currentPrice = state.currentPrice || 95000;
            const prediction = Math.random() > 0.5 ? 'COMPRA' : 'VENDA';
            const atr = currentPrice * 0.002; // 0.2% do preço
            
            const testTrade = {
                prediction,
                entryPrice: currentPrice,
                takeProfit: prediction === 'COMPRA' ? 
                    currentPrice + (3 * atr) : 
                    currentPrice - (3 * atr),
                stopLoss: prediction === 'COMPRA' ? 
                    currentPrice - (1.5 * atr) : 
                    currentPrice + (1.5 * atr),
                timestamp: Date.now(),
                avgIndicatorScore: Math.random() > 0.5 ? 
                    Math.floor(Math.random() * 30) + 20 : 
                    -Math.floor(Math.random() * 30) - 20,
                validated: false,
                endPrice: null,
                highPrice: currentPrice,
                lowPrice: currentPrice,
                result: null,
                success: null,
                realReturn: null
            };
            
            state.tradeHistory[timeframe].push(testTrade);
            saveToLocalStorage(`tradeHistory_${config.symbol}`, state.tradeHistory);
            
            // Atualizar estatísticas
            updateHistoryStats(timeframe);
            
            // Se o histórico está aberto, atualizar
            const historyDiv = document.getElementById(`history-${timeframe}`);
            if (historyDiv && historyDiv.style.display === 'block') {
                renderTradeHistory(timeframe, historyDiv);
            }
            
            console.log(`✅ Trade de teste criado:`, testTrade);
            showNotification(
                '🧪 Trade de Teste Criado',
                `${timeframe.toUpperCase()}: ${prediction} @ $${currentPrice.toFixed(2)}`,
                'info',
                3000
            );
        }
        
        // ============================================
        // CONTROLES E CONFIGURAÇÕES
        // ============================================
        function changeCrypto(symbol) {
            config.symbol = symbol;
            
            // Atualizar título e símbolos
            const symbolName = symbol.replace('USDT', '');
            
            // Atualizar header
            const headerSymbol = document.getElementById('symbol-display-header');
            if (headerSymbol) {
                headerSymbol.textContent = `${symbolName}/USDT`;
            }
            
            document.title = `${symbolName} - Análise Crypto V2.2`;
            
            // Atualizar gráficos
            ['1m', '5m', '15m', '1h'].forEach(tf => {
                const interval = tf === '1h' ? '60' : tf.replace('m', '');
                const iframe = document.querySelector(`iframe[data-timeframe="${tf}"]`);
                if (iframe) {
                    iframe.src = `https://s.tradingview.com/widgetembed/?symbol=BINANCE%3A${symbol}&interval=${interval}&theme=dark&style=1&hide_top_toolbar=1&hide_side_toolbar=1`;
                }
                document.getElementById(`chart-title-${tf}`).textContent = `${symbolName} (${tf})`;
            });
            
            // Carregar histórico
            state.tradeHistory = loadFromLocalStorage(`tradeHistory_${symbol}`, { '1m': [], '5m': [], '15m': [], '1h': [] });
            
            // CORREÇÃO: Garantir que TODOS os trades têm baseReturn
            Object.keys(state.tradeHistory).forEach(tf => {
                const history = state.tradeHistory[tf] || [];
                history.forEach(trade => {
                    if (trade.validated) {
                        // Se não tem realReturn, calcular a partir do priceChange
                        if (typeof trade.realReturn === 'undefined') {
                            const priceChange = trade.priceChange || 0;
                            let realReturn = 0;
                            
                            if (trade.prediction === 'COMPRA') {
                                realReturn = priceChange;
                            } else { // VENDA
                                realReturn = -priceChange;
                            }
                            
                            trade.baseReturn = realReturn; // Guardar retorno sem alavancagem
                            trade.realReturn = realReturn * config.leverage;
                            trade.profitWithLeverage = realReturn * config.leverage;
                        } else if (typeof trade.baseReturn === 'undefined') {
                            // Trade tem realReturn mas não tem baseReturn - calcular baseReturn
                            trade.baseReturn = trade.realReturn / config.leverage;
                        }
                    }
                });
            });
            
            // Salvar trades atualizados
            saveToLocalStorage(`tradeHistory_${symbol}`, state.tradeHistory);
            console.log('✅ Trades verificados - todos têm baseReturn');
            console.log(`📊 Histórico carregado:`, {
                '1m': state.tradeHistory['1m']?.length || 0,
                '5m': state.tradeHistory['5m']?.length || 0,
                '15m': state.tradeHistory['15m']?.length || 0,
                '1h': state.tradeHistory['1h']?.length || 0
            });
            
            // Reconectar WebSockets
            reconnectWebSockets();
            
            // Forçar análise
            state.lastAnalysisTime = 0;
            performAnalysis();
            
            // 🔄 Forçar recriação dos cards após carregar histórico (para atualizar badges)
            setTimeout(() => {
                console.log('🔄 Recriando cards após carregar histórico...');
                const gridContainer = document.querySelector('#result');
                if (gridContainer) {
                    // Remover todos os cards existentes
                    gridContainer.innerHTML = '';
                    // Forçar nova análise para recriar cards
                    state.lastAnalysisTime = 0;
                    performAnalysis();
                }
            }, 300);
            
            showNotification(`Moeda Alterada`, `Agora analisando ${symbolName}/USDT`, 'success', 3000);
        }
        
        function updateTradingModeDescription(mode) {
            const descriptions = {
                aggressive: {
                    title: '⚡ AGRESSIVO',
                    text: '• Mais tolerante com sinais\n• Maior volume de operações\n• Ideal para traders ativos\n• Maior risco de falsos positivos'
                },
                balanced: {
                    title: '⚖️ BALANCEADO',
                    text: '• Equilíbrio entre sinais e qualidade\n• Recomendado para a maioria\n• Melhor custo-benefício\n• Estratégia moderada'
                },
                conservative: {
                    title: '🛡️ CONSERVADOR',
                    text: '• Mais seletivo com sinais\n• Poucos sinais, mais confiáveis\n• Ideal para risco baixo\n• Menos operações, maior segurança'
                },
                perfect: {
                    title: '🌟 PERFECT',
                    text: '• Extremamente seletivo\n• Apenas sinais de altíssima qualidade\n• Máxima precisão, mínimas operações\n• Ideal para traders ultra conservadores'
                }
            };
            
            const desc = descriptions[mode];
            const descElement = document.getElementById('trading-mode-description');
            
            if (descElement && desc) {
                descElement.innerHTML = `
                    <div style="font-weight: bold; color: var(--accent); margin-bottom: 8px;">${desc.title}</div>
                    <div style="white-space: pre-line; color: var(--text-secondary);">${desc.text}</div>
                `;
            }
        }
        
        function updateMinSignalStrength(value) {
            const numValue = parseInt(value) || 0;
            config.minSignalStrength = numValue;
            const inputElement = document.getElementById('minSignalStrength');
            const inlineElement = document.getElementById('min-signal-inline');
            const warningElement = document.getElementById('score-warning');
            const tradingModeDisplay = document.getElementById('tradingMode');
            const tradingModeHidden = document.getElementById('tradingModeHidden');
            
            if (inlineElement) inlineElement.textContent = numValue;
            
            // Atualizar cor do input baseado no valor
            let borderColor = 'var(--accent)';
            let textColor = 'var(--accent)';
            let bgGradient = 'linear-gradient(135deg, rgba(248, 73, 96, 0.1), rgba(248, 73, 96, 0.05))';
            let warningColor = 'var(--red)';
            let newMode = 'balanced';
            let modeText = '⚖️ Balanceado';
            
            if (numValue <= 39) {
                borderColor = 'var(--red)';
                textColor = 'var(--red)';
                bgGradient = 'linear-gradient(135deg, rgba(248, 73, 96, 0.15), rgba(248, 73, 96, 0.05))';
                warningColor = 'var(--red)';
                newMode = 'aggressive';
                modeText = '⚡ Agressivo (+ sinais)';
            } else if (numValue <= 74) {
                borderColor = 'var(--accent)';
                textColor = 'var(--accent)';
                bgGradient = 'linear-gradient(135deg, rgba(240, 185, 11, 0.15), rgba(240, 185, 11, 0.05))';
                warningColor = 'var(--accent)';
                newMode = 'balanced';
                modeText = '⚖️ Balanceado';
            } else if (numValue <= 114) {
                borderColor = 'var(--green)';
                textColor = 'var(--green)';
                bgGradient = 'linear-gradient(135deg, rgba(2, 192, 118, 0.15), rgba(2, 192, 118, 0.05))';
                warningColor = 'var(--green)';
                newMode = 'conservative';
                modeText = '🛡️ Conservador (- sinais)';
            } else {
                borderColor = 'var(--blue)';
                textColor = 'var(--blue)';
                bgGradient = 'linear-gradient(135deg, rgba(56, 97, 251, 0.15), rgba(56, 97, 251, 0.05))';
                warningColor = 'var(--blue)';
                newMode = 'perfect';
                modeText = '🌟 Perfect (sinais perfeitos)';
            }
            
            if (inputElement) {
                inputElement.style.borderColor = borderColor;
                inputElement.style.color = textColor;
            }
            if (inlineElement) inlineElement.style.color = warningColor;
            if (warningElement) {
                warningElement.style.background = bgGradient;
                warningElement.style.borderLeftColor = borderColor;
            }
            
            // Atualizar display do modo de trading
            if (tradingModeDisplay) {
                tradingModeDisplay.textContent = modeText;
                tradingModeDisplay.setAttribute('data-mode', newMode);
            }
            if (tradingModeHidden) {
                tradingModeHidden.value = newMode;
            }
            
            // Atualizar todos os displays de threshold nos históricos
            document.querySelectorAll('.score-threshold-display').forEach(el => {
                el.textContent = numValue;
            });
            
            // Forçar re-renderização dos históricos abertos para atualizar a mensagem
            updateOpenHistories();
            
            // Atualizar descrição do modo
            if (newMode) {
                updateTradingModeDescription(newMode);
                showNotification(
                    '🎯 Modo Alterado',
                    `Score ${numValue} → Modo ${modeText}`,
                    'info',
                    2000
                );
            }
            
            console.log(`📊 Score mínimo atualizado: ${numValue} | Modo: ${newMode}`);
        }
        
        function updateLeverage() {
            const newLeverage = parseInt(document.getElementById('leverageSelect').value);
            const oldLeverage = config.leverage;
            config.leverage = newLeverage;
            
            let updatedCount = 0;
            
            // Recalcular realReturn de todos os trades com a nova alavancagem
            Object.keys(state.tradeHistory).forEach(tf => {
                const trades = state.tradeHistory[tf] || [];
                trades.forEach(trade => {
                    if (trade.validated) {
                        // Se não tem baseReturn, criar a partir de realReturn atual dividindo pela alavancagem anterior
                        if (trade.baseReturn === undefined && trade.realReturn !== undefined) {
                            trade.baseReturn = trade.realReturn / oldLeverage;
                        }
                        
                        // Se tem baseReturn, recalcular com a nova alavancagem
                        if (trade.baseReturn !== undefined) {
                            trade.realReturn = trade.baseReturn * config.leverage;
                            updatedCount++;
                        }
                    }
                });
            });
            
            console.log(`🔄 Alavancagem atualizada: ${oldLeverage}x → ${config.leverage}x (${updatedCount} trades atualizados)`);
            
            // Atualizar estatísticas de todos os timeframes
            ['1m', '5m', '15m', '1h'].forEach(tf => {
                updateHistoryStats(tf);
            });
            
            // Atualizar estatísticas gerais
            updateOverallStats();
            
            showNotification(`Alavancagem Ajustada`, `Novo valor: ${config.leverage}x (era ${oldLeverage}x)`, 'info', 3000);
        }
        
        // 🧠 FUNÇÃO DE TESTE: Forçar verificação do sistema adaptativo
        function forceAdaptiveCheck() {
            console.log('');
            console.log('╔══════════════════════════════════════════════╗');
            console.log('║ 🧪 VERIFICAÇÃO MANUAL FORÇADA               ║');
            console.log('╚══════════════════════════════════════════════╝');
            
            let totalChecked = 0;
            let totalAdjusted = 0;
            let totalPending = 0;
            let detailsText = '';
            
            Object.keys(state.tradeHistory).forEach(tf => {
                const all = state.tradeHistory[tf] || [];
                const validated = all.filter(t => t.validated && !t.isManual);
                const pending = all.filter(t => !t.validated);
                
                console.log(`📊 ${tf}: ${all.length} trades total (${validated.length} validados, ${pending.length} aguardando)`);
                
                if (validated.length > 0) {
                    // Tem pelo menos 1 trade validado - pode ajustar pesos
                    const modeBefore = state.adaptiveSystem[tf].mode;
                    const weightsBefore = JSON.stringify(state.adaptiveSystem[tf].indicatorWeights);
                    
                    updateAdaptiveSystem(tf);
                    
                    const modeAfter = state.adaptiveSystem[tf].mode;
                    const weightsAfter = JSON.stringify(state.adaptiveSystem[tf].indicatorWeights);
                    
                    totalChecked++;
                    
                    if (modeBefore !== modeAfter || weightsBefore !== weightsAfter) {
                        totalAdjusted++;
                        detailsText += `${tf}: `;
                        if (modeBefore !== modeAfter) detailsText += `modo ${modeBefore}→${modeAfter} `;
                        if (weightsBefore !== weightsAfter) detailsText += `pesos ajustados `;
                        detailsText += '\n';
                    }
                    
                    // Mostrar detalhes dos pesos
                    const weights = state.adaptiveSystem[tf].indicatorWeights;
                    const modifiedWeights = Object.entries(weights).filter(([_, w]) => w !== 1);
                    if (modifiedWeights.length > 0) {
                        console.log(`   🎯 Pesos modificados:`, modifiedWeights.map(([k, w]) => `${k}=${w.toFixed(1)}x`).join(', '));
                    }
                } else if (all.length > 0) {
                    console.log(`   ⏳ ${tf}: ${pending.length} trade(s) aguardando validação`);
                    totalPending++;
                } else {
                    console.log(`   ⚪ ${tf}: Nenhum trade registrado ainda`);
                }
            });
            
            // Atualizar cards visuais
            updateAdaptiveStatusCard();
            
            // Forçar atualização visual dos cards
            setTimeout(() => performAnalysis(), 500);
            
            console.log('');
            console.log(`✅ Verificação concluída: ${totalChecked} timeframes checados, ${totalAdjusted} ajustados, ${totalPending} aguardando`);
            
            let message = '';
            if (totalChecked > 0) {
                message = `${totalChecked} checado(s) • ${totalAdjusted} ajustado(s)`;
            } else if (totalPending > 0) {
                message = `${totalPending} timeframe(s) com trades pendentes`;
            } else {
                message = 'Nenhum trade validado ainda';
            }
            
            if (detailsText) {
                message += '\n' + detailsText;
            }
            
            showNotification(
                '🧠 Sistema Adaptativo Verificado',
                message,
                totalChecked > 0 ? 'success' : 'info',
                5000
            );
        }
        
        // 🔄 RESETAR SISTEMA ADAPTATIVO
        function resetAdaptiveSystem(timeframe = null) {
            const defaultConfig = {
                threshold: 10,
                indicatorWeights: { rsi: 1, macd: 1, stochRsi: 1, mfi: 1, trend: 1, occ: 1, stcCci: 1 },
                lastAdjustment: Date.now(),
                mode: 'normal',
                performanceWindow: []
            };
            
            const timeframesToReset = timeframe ? [timeframe] : ['1m', '5m', '15m', '1h'];
            
            console.log(timeframe ? 
                `🔄 Resetando sistema adaptativo para ${timeframe}` : 
                '🔄 Resetando TODO o sistema adaptativo'
            );
            
            timeframesToReset.forEach(tf => {
                // Reset da configuração
                state.adaptiveSystem[tf] = { ...defaultConfig };
                console.log(`  ✅ ${tf}: Threshold → 10%, Modo → normal`);
                
                // 🗑️ FORÇAR REMOÇÃO DE BADGES E INFO CARD deste timeframe
                const card = document.querySelector(`[data-timeframe="${tf}"]`);
                if (card) {
                    const badges = card.querySelectorAll('.adaptive-badge');
                    const infos = card.querySelectorAll('.adaptive-info');
                    const adaptiveInfoCards = card.querySelectorAll('[style*="SISTEMA ADAPTATIVO ATIVO"]');
                    
                    // Remover todas as divs que contêm "SISTEMA ADAPTATIVO ATIVO"
                    const allDivs = card.querySelectorAll('div');
                    allDivs.forEach(div => {
                        if (div.textContent.includes('SISTEMA ADAPTATIVO ATIVO')) {
                            console.log(`  🗑️ Removendo card adaptativo de ${tf}`);
                            div.remove();
                        }
                    });
                    
                    if (badges.length > 0 || infos.length > 0) {
                        console.log(`  🗑️ Removendo ${badges.length} badges e ${infos.length} infos de ${tf}`);
                        badges.forEach(b => b.remove());
                        infos.forEach(i => i.remove());
                    }
                }
            });
            
            // Salvar no localStorage
            saveToLocalStorage(`adaptiveSystem_${config.symbol}`, state.adaptiveSystem);
            
            // Atualizar visual
            updateAdaptiveStatusCard();
            
            // Forçar atualização dos cards após 500ms
            setTimeout(() => {
                console.log('🔄 Forçando re-análise após reset...');
                performAnalysis();
            }, 500);
            
            const message = timeframe ? 
                `${timeframe.toUpperCase()} resetado para padrão` : 
                'Todos os timeframes resetados';
            
            showNotification(
                '🔄 Sistema Adaptativo Resetado',
                message,
                'success',
                3000
            );
        }
        
        function updateRefreshInterval() {
            config.refreshInterval = parseInt(document.getElementById('refreshInterval').value);
            
            if (intervalId) {
                clearInterval(intervalId);
            }
            
            intervalId = setInterval(performAnalysis, config.refreshInterval);
            showNotification(`Intervalo Atualizado`, `Atualizando a cada ${config.refreshInterval / 1000}s`, 'info', 3000);
        }
        
        function reconnectWebSockets() {
            // Fechar conexões existentes
            [state.ws, state.wsPrice, state.wsOrderbook].forEach(ws => {
                if (ws) {
                    ws.onclose = null;
                    ws.close();
                }
            });
            
            const symbol = config.symbol.toLowerCase();
            
            // Reconectar análise
            state.ws = setupWebSocket(
                `wss://stream.binance.com:9443/ws/${symbol}@ticker`,
                () => performAnalysis(),
                'status-dot-analysis'
            );
            
            // Reconectar preço
            state.wsPrice = setupWebSocket(
                `wss://stream.binance.com:9443/ws/${symbol}@miniTicker`,
                (e) => {
                    const data = JSON.parse(e.data);
                    state.currentPrice = parseFloat(data.c);
                    
                    // Validar trades pendentes
                    validateTrades(state.currentPrice);
                    
                    // Atualizar históricos abertos
                    updateOpenHistories();
                },
                'status-dot-price'
            );
            
            // Reconectar orderbook para baleias
            if (config.whaleTracking) {
                initWhaleTracking();
            }
        }
        
        function initWhaleTracking() {
            if (state.wsOrderbook) {
                state.wsOrderbook.onclose = null;
                state.wsOrderbook.close();
            }
            
            const symbol = config.symbol.toLowerCase();
            
            state.wsOrderbook = setupWebSocket(
                `wss://fstream.binance.com/ws/${symbol}@depth`,
                (e) => {
                    const data = JSON.parse(e.data);
                    processWhaleOrders(data);
                },
                'status-dot-whale'
            );
            
            state.whaleSummary = { buy: 0, sell: 0, buyPressure: 0.5 };
            document.getElementById('whale-orders').innerHTML = '';
        }
        
        function updateWhaleFilter(value) {
            config.whaleMinValue = parseInt(value);
            
            // Atualizar display do valor
            const displayValue = formatCurrency(value);
            
            // Limpar ordens atuais
            document.getElementById('whale-orders').innerHTML = '';
            state.whaleSummary = { buy: 0, sell: 0, buyPressure: 0.5 };
            
            // Atualizar summary
            document.getElementById('whale-buy-total').textContent = '$0.00M';
            document.getElementById('whale-sell-total').textContent = '$0.00M';
            document.getElementById('whale-pressure-fill').style.width = '50%';
            document.getElementById('whale-pressure-text').textContent = '50% Compra';
            
            showNotification(
                'Filtro de Baleias Atualizado', 
                `Novo valor mínimo: ${displayValue}`, 
                'info', 
                3000
            );
        }
        
        function updateWhaleDisplay(value) {
            // Função para atualizar o display enquanto o slider é arrastado
            const displayValue = formatCurrency(value);
            const inputElement = document.getElementById('whale-min-input');
            if (inputElement) {
                inputElement.value = displayValue;
            }
        }
        
        function updateWhaleFilterFromInput(value) {
            // Função para atualizar quando o input numérico é alterado
            const numValue = parseInputCurrency(value);
            const slider = document.getElementById('whaleMinValue');
            slider.value = numValue;
            updateWhaleFilter(numValue);
        }
        
        function parseInputCurrency(input) {
            // Parse de valores como "5B", "500M", "10K"
            const str = String(input).trim().toUpperCase();
            let multiplier = 1;
            let numStr = str;
            
            if (str.endsWith('B')) {
                multiplier = 1000000000;
                numStr = str.slice(0, -1);
            } else if (str.endsWith('M')) {
                multiplier = 1000000;
                numStr = str.slice(0, -1);
            } else if (str.endsWith('K')) {
                multiplier = 1000;
                numStr = str.slice(0, -1);
            }
            
            const num = parseFloat(numStr) || 0;
            return Math.round(num * multiplier);
        }
        
        function formatCurrency(value) {
            // Formata valor em moeda
            const numValue = parseInt(value) || 0;

            if (numValue >= 1000000000) {
                return `$${(numValue / 1000000000).toFixed(2)}B`;
            } else if (numValue >= 1000000) {
                return `$${(numValue / 1000000).toFixed(1)}M`;
            } else if (numValue >= 1000) {
                return `$${(numValue / 1000).toFixed(0)}K`;
            } else {
                return `$${numValue}`;
            }
        }
        
        function processWhaleOrders(data) {
            const MIN_ORDER_VALUE = config.whaleMinValue; // Usar valor configurável
            
            // Processar bids (compras)
            data.b.forEach(([price, qty]) => {
                const value = parseFloat(price) * parseFloat(qty);
                if (value > MIN_ORDER_VALUE) {
                    state.whaleSummary.buy += value;
                    addWhaleOrder('buy', price, qty, value);
                }
            });
            
            // Processar asks (vendas)
            data.a.forEach(([price, qty]) => {
                const value = parseFloat(price) * parseFloat(qty);
                if (value > MIN_ORDER_VALUE) {
                    state.whaleSummary.sell += value;
                    addWhaleOrder('sell', price, qty, value);
                }
            });
            
            // Atualizar pressão
            const total = state.whaleSummary.buy + state.whaleSummary.sell;
            state.whaleSummary.buyPressure = total > 0 ? state.whaleSummary.buy / total : 0.5;
            
            // Atualizar UI
            document.getElementById('whale-buy-total').textContent = `$${(state.whaleSummary.buy / 1000000).toFixed(2)}M`;
            document.getElementById('whale-sell-total').textContent = `$${(state.whaleSummary.sell / 1000000).toFixed(2)}M`;
            document.getElementById('whale-pressure-fill').style.width = `${state.whaleSummary.buyPressure * 100}%`;
            document.getElementById('whale-pressure-text').textContent = `${(state.whaleSummary.buyPressure * 100).toFixed(0)}% Compra`;
        }
        
        function addWhaleOrder(type, price, qty, value) {
            const container = document.getElementById('whale-orders');
            const orderId = `whale-${type}-${price.replace('.', '')}`;
            
            if (document.getElementById(orderId)) return;
            
            const orderDiv = document.createElement('div');
            orderDiv.id = orderId;
            orderDiv.className = `whale-order whale-${type}`;
            orderDiv.innerHTML = `
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <strong>${type === 'buy' ? '🟢 COMPRA' : '🔴 VENDA'}</strong>
                    <span style="font-weight: bold; color: var(--accent);">$${(value / 1000000).toFixed(2)}M</span>
                </div>
                <div style="font-size: 11px; color: var(--text-secondary); display: flex; justify-content: space-between;">
                    <span>Preço: $${parseFloat(price).toFixed(5)}</span>
                    <span>Qtd: ${parseFloat(qty).toFixed(2)}</span>
                </div>
            `;
            
            container.insertBefore(orderDiv, container.firstChild);
            
            // Limitar a 30 ordens
            while (container.children.length > 30) {
                container.removeChild(container.lastChild);
            }
        }
        
        function updateCountdown() {
            const timeLeft = Math.max(0, config.refreshInterval - (Date.now() - state.lastAnalysisTime));
            const seconds = Math.ceil(timeLeft / 1000);
            
            // Atualizar contador inline (novo design)
            const inlineEl = document.getElementById('countdown-timer-inline');
            if (inlineEl) {
                inlineEl.textContent = `${seconds}s`;
            }
            
            if (seconds <= 0) {
                setTimeout(updateCountdown, 100);
            } else {
                setTimeout(updateCountdown, 1000);
            }
        }
        
        // ============================================
        // 🎯 ATUALIZAR SIDEBAR DE SINAIS
        // ============================================
        function updateSignalsSidebar() {
            const today = new Date().setHours(0, 0, 0, 0);
            
            const allSignals = Object.entries(state.tradeHistory)
                .flatMap(([timeframe, trades]) => 
                    trades
                        .filter(trade => trade.timestamp >= today) // Apenas sinais de hoje
                        .map(trade => ({ ...trade, timeframe }))
                )
                .sort((a, b) => b.timestamp - a.timestamp);
            
            const countEl = document.getElementById('signals-count-sidebar');
            const listEl = document.getElementById('signals-list');
            
            if (!countEl || !listEl) return;
            
            // Atualizar contador real baseado nos sinais de hoje
            const todaySignalsCount = allSignals.length;
            state.sessionStats.signalsToday = todaySignalsCount;
            countEl.textContent = todaySignalsCount;
            
            // Atualizar também o card principal - não precisa mais atualizar aqui
            // pois updateOverallStats() já faz isso
            
            // Atualizar contador da sidebar de sinais (apenas acertos)
            const confirmedCount = allSignals.filter(s => s.validated && s.success).length;
            const confirmedSidebarEl = document.getElementById('signals-confirmed-sidebar');
            if (confirmedSidebarEl) {
                confirmedSidebarEl.textContent = `${confirmedCount} confirmados`;
            }
            
            if (allSignals.length === 0) {
                listEl.innerHTML = `
                    <div style="color: var(--text-secondary); text-align: center; padding: 20px;">
                        Nenhum sinal registrado hoje...
                    </div>
                `;
                return;
            }
            
            // Mostrar últimos 20
            const displaySignals = allSignals.slice(0, 20);
            
            listEl.innerHTML = displaySignals.map(signal => {
                const direction = signal.prediction || signal.direction || 'NEUTRAL';
                const directionColor = direction === 'COMPRA' || direction === 'BUY' ? 'var(--green)' : 
                                      direction === 'VENDA' || direction === 'SELL' ? 'var(--red)' : 
                                      'var(--text-secondary)';
                const directionIcon = direction === 'COMPRA' || direction === 'BUY' ? '🟢' : 
                                     direction === 'VENDA' || direction === 'SELL' ? '🔴' : '⚪';
                
                const validated = signal.validated;
                const success = signal.success;
                const statusIcon = !validated ? '⏳' : success ? '✅' : '❌';
                const statusText = !validated ? 'Pendente' : success ? 'Acertou' : 'Errou';
                const statusColor = !validated ? 'var(--accent)' : success ? 'var(--green)' : 'var(--red)';
                
                const timeStr = new Date(signal.timestamp).toLocaleTimeString('pt-BR', { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                const returnStr = signal.realReturn !== undefined ? 
                    `${signal.realReturn >= 0 ? '+' : ''}${signal.realReturn.toFixed(2)}%` : '-';
                
                return `
                    <div style="
                        padding: 10px;
                        margin-bottom: 8px;
                        background: var(--bg-dark);
                        border-radius: 6px;
                        border-left: 3px solid ${directionColor};
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <span style="font-size: 12px;">${directionIcon}</span>
                                <span style="color: ${directionColor}; font-weight: 600; font-size: 11px;">
                                    ${direction}
                                </span>
                                <span style="color: var(--text-secondary); font-size: 10px;">
                                    ${signal.timeframe}
                                </span>
                            </div>
                            <span style="font-size: 10px; color: var(--text-secondary);">
                                ${timeStr}
                            </span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; font-size: 10px;">
                            <div style="color: ${statusColor};">
                                ${statusIcon} ${statusText}
                            </div>
                            <div style="color: ${signal.realReturn >= 0 ? 'var(--green)' : 'var(--red)'}; font-weight: 600;">
                                ${returnStr}
                            </div>
                        </div>
                        <div style="font-size: 9px; color: var(--text-secondary); margin-top: 4px;">
                            Entrada: $${signal.entryPrice?.toFixed(2) || '-'}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // ============================================
        // 🎯 TOGGLE SIDEBAR DE SINAIS
        // ============================================
        function toggleSignalsSidebar() {
            const signalsSidebar = document.getElementById('sidebar-signals');
            const signalsToggle = document.getElementById('sidebar-signals-toggle');
            const whaleSidebar = document.getElementById('sidebar');
            const whaleToggle = document.getElementById('sidebar-toggle');
            const mainContent = document.querySelector('.main-content');
            
            signalsSidebar.classList.toggle('collapsed');
            signalsToggle.classList.toggle('collapsed');
            
            if (signalsSidebar.classList.contains('collapsed')) {
                signalsToggle.textContent = '🎯';
                mainContent.classList.remove('with-sidebar');
            } else {
                signalsToggle.textContent = '🎯 SINAIS';
                mainContent.classList.add('with-sidebar');
                
                // Fechar sidebar de baleias se estiver aberta
                if (!whaleSidebar.classList.contains('collapsed')) {
                    whaleSidebar.classList.add('collapsed');
                    whaleToggle.classList.add('collapsed');
                    whaleToggle.textContent = '🐋';
                }
            }
        }
        
        // ============================================
        // INICIALIZAÇÃO
        // ============================================
        
        // ============================================
        // 🎯 TRADE MANUAL (TESTE DE PALPITE)
        // ============================================
        function manualTrade(timeframe, direction) {
            console.log(`🎯 Trade manual iniciado: ${timeframe} ${direction}`);
            
            // Validar parâmetros
            if (!['1m', '5m', '15m', '1h'].includes(timeframe)) {
                alert('⚠️ Timeframe inválido!');
                return;
            }
            
            if (!['BUY', 'SELL'].includes(direction)) {
                alert('⚠️ Direção inválida!');
                return;
            }
            
            // Obter preço atual
            const currentPrice = state.currentPrice || 0;
            if (currentPrice === 0) {
                alert('⚠️ Aguarde... preço ainda não disponível.');
                return;
            }
            
            // Obter análise atual do cache (se disponível)
            const cacheKey = `${config.symbol}_${timeframe}`;
            const cachedAnalysis = state.indicatorCache[cacheKey];
            
            // Criar análise para trade manual (com dados reais se disponíveis)
            const manualAnalysis = {
                timeframe: timeframe,
                direction: direction === 'BUY' ? 'COMPRA' : 'VENDA',
                score: cachedAnalysis?.score || 0,
                currentPrice: currentPrice,
                atr: cachedAnalysis?.atr || (currentPrice * 0.01),
                confidence: cachedAnalysis?.confidence || 0,
                explanation: '🎯 Trade manual (não afeta aprendizado)',
                isManual: true, // Flag para identificar trade manual
                indicators: cachedAnalysis?.indicators || {
                    rsi: { value: 50, score: 0 },
                    macd: { value: 0, score: 0 },
                    stochRsi: { value: 50, score: 0 },
                    mfi: { value: 50, score: 0 },
                    trend: { value: 'sideways', score: 0 }
                }
            };
            
            // Rastrear o trade
            trackTrade(timeframe, manualAnalysis);
            
            // Notificar usuário
            const directionEmoji = direction === 'BUY' ? '📈' : '📉';
            const directionText = direction === 'BUY' ? 'COMPRA' : 'VENDA';
            alert(`${directionEmoji} Trade manual registrado!\n\n` +
                  `Timeframe: ${timeframe}\n` +
                  `Direção: ${directionText}\n` +
                  `Preço: $${currentPrice.toFixed(2)}\n\n` +
                  `O trade será avaliado automaticamente após o período de validação.`);
            
            // Atualizar sidebar de sinais
            updateSignalsSidebar();
        }
        
        // ============================================
        // 🐋 SIDEBAR COLAPSÁVEL
        // ============================================
        function toggleSidebar() {
            const whaleSidebar = document.getElementById('sidebar');
            const whaleToggle = document.getElementById('sidebar-toggle');
            const signalsSidebar = document.getElementById('sidebar-signals');
            const signalsToggle = document.getElementById('sidebar-signals-toggle');
            const mainContent = document.querySelector('.main-content');
            
            whaleSidebar.classList.toggle('collapsed');
            whaleToggle.classList.toggle('collapsed');
            
            if (whaleSidebar.classList.contains('collapsed')) {
                whaleToggle.textContent = '🐋';
                mainContent.classList.remove('with-sidebar');
            } else {
                whaleToggle.textContent = '🐋 BALEIAS';
                mainContent.classList.add('with-sidebar');
                
                // Fechar sidebar de sinais se estiver aberta
                if (!signalsSidebar.classList.contains('collapsed')) {
                    signalsSidebar.classList.add('collapsed');
                    signalsToggle.classList.add('collapsed');
                    signalsToggle.textContent = '🎯';
                }
            }
        }

        // ============================================
        // 📊 SISTEMA DE BACKTESTING
        // ============================================
        let backtestData = { timeframe: null, config: {}, results: null, chart: null, endTime: null, anchorPeriod: 30 };

        function openBacktestModal(timeframe) {
            // Bloquear backtest para 1m (dados insuficientes da API)
            if (timeframe === '1m') {
                alert('⚠️ Backtest não disponível para 1m\n\nA API Binance retorna apenas 200 velas para 1m, insuficiente para análise (necessário 201+ velas).\n\nUse 5m, 15m ou 1h para backtest.');
                return;
            }
            
            console.log('📂 Abrindo modal de backtest para timeframe:', timeframe);
            console.log('🔍 Modal element:', document.getElementById('backtest-modal'));
            backtestData.timeframe = timeframe;
            backtestData.endTime = Date.now(); // Fixar o tempo para todos os backtests
            backtestData.anchorPeriod = 30; // Alinhar janelas (7/14 são os primeiros dias desse período)
            document.getElementById('backtest-timeframe-display').textContent = timeframe.toUpperCase();
            document.getElementById('backtest-modal').style.display = 'block';
            document.body.style.overflow = 'hidden';
            console.log('✅ Modal deve estar visível agora');
        }

        function closeBacktestModal() {
            document.getElementById('backtest-modal').style.display = 'none';
            document.body.style.overflow = 'auto';
            document.getElementById('backtest-results').style.display = 'none';
            if (backtestData.chart) {
                backtestData.chart.destroy();
                backtestData.chart = null;
            }
        }

        async function runBacktest() {
            console.log('🚀 Iniciando backtest...');
            const period = parseInt(document.getElementById('backtest-period').value);
            const capital = parseFloat(document.getElementById('backtest-capital').value);
            const leverage = parseInt(document.getElementById('backtest-leverage').value);
            
            console.log('📊 Configurações:', { period, capital, leverage, timeframe: backtestData.timeframe });
            
            backtestData.config = { period, capital, leverage, backtestThreshold: 5 };
            
            document.getElementById('backtest-results').style.display = 'none';
            document.getElementById('backtest-loading').style.display = 'block';
            
            try {
                // Usar o timeframe selecionado pelo usuário
                const backtestTimeframe = backtestData.timeframe;
                
                // Calcular minutos por vela baseado no timeframe
                const timeframeMinutes = {
                    '1m': 1,
                    '5m': 5,
                    '15m': 15,
                    '1h': 60
                };
                const minutesPerCandle = timeframeMinutes[backtestTimeframe] || 60;
                const candlesPerDay = (24 * 60) / minutesPerCandle;
                
                // SEMPRE pedir o máximo de velas que a API permite (1000)
                const limit = 1000;
                
                // Calcular quantos dias reais isso representa
                const maxDaysForTimeframe = Math.floor(1000 / candlesPerDay);
                const adjustedPeriod = Math.min(period, maxDaysForTimeframe);
                
                if (adjustedPeriod < period) {
                    console.warn(`⚠️ Período ajustado de ${period} para ${adjustedPeriod} dias devido a limites da API para timeframe ${backtestTimeframe}`);
                }
                
                // Salvar período ajustado
                backtestData.config.period = adjustedPeriod;
                backtestData.config.periodAdjusted = adjustedPeriod < period;
                
                console.log('📡 Buscando dados para backtest:', { 
                    symbol: config.symbol, 
                    interval: backtestTimeframe, 
                    limit: limit,
                    periodAdjusted: adjustedPeriod !== period ? `${period}→${adjustedPeriod} dias` : 'não ajustado'
                });
                
                const response = await axios.get(
                    `https://api.binance.com/api/v3/klines?symbol=${config.symbol}&interval=${backtestTimeframe}&limit=${limit}`
                );
                
                console.log('✅ Dados recebidos:', response.data.length, 'velas');
                
                await processBacktest(response.data);
            } catch (error) {
                console.error('❌ Erro no backtest:', error);
                alert('Erro: ' + error.message);
                closeBacktestModal();
            }
        }

        async function processBacktest(klines) {
            console.log('🔄 Processando backtest com', klines.length, 'velas recebidas no timeframe', backtestData.timeframe);

            // Ajustar warm-up dinamicamente baseado nas velas disponíveis
            const maxWarmup = 200;
            const minWarmup = 50; // Mínimo aceitável para indicadores funcionarem
            
            if (klines.length < minWarmup + 1) {
                console.warn('Dados insuficientes para backtest - mínimo 51 velas necessário');
                alert(`Dados insuficientes para backtest.\nNecessário: 51 velas mínimo\nRecebido da API: ${klines.length} velas\n\nA API Binance não retornou dados suficientes para ${backtestData.timeframe}.`);
                document.getElementById('backtest-loading').style.display = 'none';
                return;
            }
            
            // Usar warm-up adaptativo: 200 se tiver, ou 75% das velas disponíveis
            const warmupCandles = Math.min(maxWarmup, Math.floor(klines.length * 0.75));
            console.log(`📊 Usando ${warmupCandles} velas para warm-up de ${klines.length} disponíveis`);
            
            // Calcular velas por dia baseado no timeframe
            const timeframeMinutes = {
                '1m': 1,
                '5m': 5,
                '15m': 15,
                '1h': 60
            };
            const minutesPerCandle = timeframeMinutes[backtestData.timeframe] || 60;
            const candlesPerDay = (24 * 60) / minutesPerCandle;
            
            // Calcular quantas velas são necessárias para o período solicitado
            const requestedPeriod = backtestData.config.period;
            const requestedCandles = Math.ceil(requestedPeriod * candlesPerDay);
            const totalNeeded = warmupCandles + requestedCandles;
            
            // Usar as velas disponíveis
            let sliced;
            let periodAdjusted = false;
            
            if (klines.length >= totalNeeded) {
                // Temos velas suficientes - pegar só o período solicitado do final
                sliced = klines.slice(klines.length - totalNeeded);
                console.log(`✅ Usando ${sliced.length} velas (período completo de ${requestedPeriod} dias)`);
            } else {
                // Não temos velas suficientes - usar todas disponíveis
                sliced = klines;
                periodAdjusted = true;
                console.log(`⚠️ Usando todas as ${sliced.length} velas disponíveis (período ajustado)`);
            }
            
            const windowEndIndex = sliced.length;
            const analyzedCandles = sliced.length - warmupCandles;
            const realDays = analyzedCandles / candlesPerDay;

            console.log('⏱️ Backtest Config:', {
                timeframe: backtestData.timeframe,
                periodoSolicitado: requestedPeriod + ' dias',
                periodAdjusted: periodAdjusted,
                totalVelas: sliced.length,
                warmupVelas: warmupCandles,
                velasProcessadas: analyzedCandles,
                diasReais: realDays.toFixed(2)
            });
            
            // Salvar se foi ajustado
            backtestData.config.periodAdjusted = periodAdjusted;
            backtestData.config.realDays = realDays;

            console.log('📅 Primeira vela usada:', new Date(parseInt(sliced[0][0])).toLocaleString());
            console.log('📅 Última vela usada:', new Date(parseInt(sliced[sliced.length - 1][0])).toLocaleString());

            const { capital, leverage } = backtestData.config;
            let currentCapital = capital;
            const trades = [];
            const equityHistory = [];
            const dates = [];

            // Adicionar ponto inicial (verificar se existe)
            if (sliced.length > warmupCandles) {
                equityHistory.push(currentCapital);
                dates.push(new Date(parseInt(sliced[warmupCandles][0])));
            } else {
                console.error('❌ Não há velas suficientes após warm-up');
                alert(`Dados insuficientes. Tem ${sliced.length} velas, precisa de ${warmupCandles + 1} mínimo.`);
                document.getElementById('backtest-loading').style.display = 'none';
                return;
            }
            
            // Calcular intervalo para adicionar pontos (a cada ~50 velas ou 5% do total)
            const totalCandles = windowEndIndex - warmupCandles - 1;
            const pointInterval = Math.max(1, Math.floor(totalCandles / 20)); // 20 pontos no gráfico
            console.log(`📊 Adicionando ponto no gráfico a cada ${pointInterval} velas. Total a processar: ${totalCandles}`);

            for (let i = warmupCandles; i < windowEndIndex - 1; i++) {
                const kline = sliced[i];

                // Adicionar ponto ao gráfico em intervalos regulares
                if ((i - warmupCandles) % pointInterval === 0 && i > warmupCandles) {
                    console.log(`📊 Ponto ${equityHistory.length}: vela ${i} - Capital: $${currentCapital.toFixed(2)}`);
                    equityHistory.push(currentCapital);
                    dates.push(new Date(parseInt(kline[0])));
                }

                const historicalKlines = sliced.slice(i - 200, i);
                if (historicalKlines.length < 200) continue; // Pular se não há dados suficientes
                
                const analysis = analyzeHistoricalCandles(historicalKlines);

                const entryPrice = parseFloat(sliced[i][4]);
                const exitPrice = parseFloat(sliced[i + 1][4]);
                const score = Number.isFinite(analysis.score) ? analysis.score : 0;
                
                // 🎯 USAR O SCORE MÍNIMO DO SLIDER (config.minSignalStrength)
                const minSignalStrength = config.minSignalStrength || 50;
                const scoreAbs = Math.abs(score);
                
                // Só abrir posição se o score atingir o mínimo configurado
                if (scoreAbs >= minSignalStrength) {
                    const position = score > 0 ? 1 : -1; // Posição completa (100%)
                    const priceChange = ((exitPrice - entryPrice) / entryPrice) * 100;
                    const returnPercent = priceChange * leverage * position;
                    const profit = (currentCapital * returnPercent) / 100;
                    currentCapital += profit;

                    trades.push({
                        date: new Date(parseInt(sliced[i][0])),
                        prediction: position > 0 ? 'COMPRA' : 'VENDA',
                        entryPrice,
                        exitPrice,
                        profit,
                        capital: currentCapital,
                        success: profit > 0,
                        score: score
                    });
                }
            }
            
            // Adicionar ponto final
            if (equityHistory[equityHistory.length - 1] !== currentCapital) {
                equityHistory.push(currentCapital);
                dates.push(new Date(parseInt(sliced[windowEndIndex - 1][0])));
            }

            console.log(`📊 Gráfico final: ${dates.length} pontos, ${equityHistory.length} pontos de equity`);

            console.log(`📊 Backtest finalizado: ${trades.length} trades, ${equityHistory.length} pontos no gráfico`);
            
            const wins = trades.filter(t => t.success).length;
            const winRate = trades.length > 0 ? (wins / trades.length) * 100 : 0;
            const totalReturn = ((currentCapital - capital) / capital) * 100;
            
            // Calcular período real analisado (baseado nas velas do slice, não do array original)
            const firstTimestamp = sliced[warmupCandles][0];
            const lastTimestamp = sliced[sliced.length - 1][0];
            const totalMinutes = (lastTimestamp - firstTimestamp) / (1000 * 60);
            const totalHours = totalMinutes / 60;
            const totalDays = totalHours / 24;

            backtestData.results = {
                trades,
                equityHistory,
                dates,
                stats: {
                    totalTrades: trades.length,
                    wins,
                    losses: trades.length - wins,
                    winRate,
                    totalReturn,
                    finalCapital: currentCapital,
                    totalCandles: sliced.length,
                    analyzedCandles: sliced.length - warmupCandles,
                    realDays: totalDays,
                    realHours: totalHours
                }
            };

            displayBacktestResults();
        }

        function analyzeHistoricalCandles(klines) {
            // Usar o engine de análise para consistência com o timeframe selecionado
            const marketData = {
                klines: klines,
                timeframe: backtestData.timeframe, // Usar timeframe do backtest
                config: {
                    ...config,
                    backtestThreshold: backtestData.config.backtestThreshold,
                    trendFilter: false
                }
            };

            try {
                const analysisResult = window.MarketAnalysisEngine.analyzeMarket(marketData);
                let score = analysisResult.totalScore;

                if (!Number.isFinite(score) || Math.abs(score) < 0.5) {
                    const closes = klines.map(k => parseFloat(k[4]));
                    const lookback = Math.min(30, closes.length);
                    const slice = closes.slice(-lookback);
                    const sma = slice.reduce((a, b) => a + b, 0) / slice.length;
                    const last = closes[closes.length - 1];
                    const momentum = ((last - sma) / sma) * 100;
                    score = momentum;
                }

                return { score: Number.isFinite(score) ? score : 0, direction: analysisResult.direction };
            } catch (error) {
                console.error('Erro no backtest analysis:', error);
                return { score: 0, direction: 'NEUTRAL' };
            }
        }

        function displayBacktestResults() {
            console.log('📈 Iniciando displayBacktestResults...');
            console.log('📊 backtestData.results:', backtestData.results);
            
            const { stats, equityHistory, dates } = backtestData.results;
            
            console.log('📈 Exibindo gráfico:', {
                trades: stats.totalTrades,
                equityPoints: equityHistory.length,
                datePoints: dates.length,
                equityRange: `${equityHistory[0]} -> ${equityHistory[equityHistory.length - 1]}`
            });
            
            document.getElementById('backtest-loading').style.display = 'none';
            document.getElementById('backtest-results').style.display = 'block';
            
            // Mostrar informações sobre período analisado
            const timeInfo = stats.realDays >= 1 
                ? `${stats.realDays.toFixed(1)} dia(s)` 
                : `${stats.realHours.toFixed(1)} hora(s)`;
            
            const periodWarning = backtestData.config.periodAdjusted 
                ? `<div style="color: var(--accent); margin-top: 4px;">⚠️ Período ajustado: solicitado ${backtestData.config.period} dias, analisado ${stats.realDays.toFixed(1)} dias</div>`
                : '';
                
            const periodInfo = `
                <div style="background: rgba(240, 185, 11, 0.1); border: 1px solid var(--accent); border-radius: 8px; padding: 12px; margin-bottom: 16px;">
                    <div style="display: flex; align-items: center; gap: 8px; color: var(--accent); font-size: 13px;">
                        📊 <strong>Período Analisado (${backtestData.timeframe.toUpperCase()})</strong>
                    </div>
                    <div style="font-size: 11px; color: var(--text-secondary); margin-top: 6px;">
                        ${stats.totalCandles} velas disponíveis • ${stats.analyzedCandles} velas processadas • ~${timeInfo}
                        ${periodWarning}
                    </div>
                </div>
            `;
            
            const statsHtml = `
                ${periodInfo}
                <div class="backtest-stat-card">
                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">CAPITAL FINAL</div>
                    <div class="backtest-stat-value ${stats.totalReturn >= 0 ? 'positive' : 'negative'}">
                        $${stats.finalCapital.toFixed(2)}
                    </div>
                    <div style="font-size: 14px; margin-top: 5px;">
                        ${stats.totalReturn >= 0 ? '+' : ''}${stats.totalReturn.toFixed(2)}%
                    </div>
                </div>
                <div class="backtest-stat-card">
                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">WIN RATE</div>
                    <div class="backtest-stat-value ${stats.winRate >= 50 ? 'positive' : 'negative'}">
                        ${stats.winRate.toFixed(1)}%
                    </div>
                    <div style="font-size: 14px; margin-top: 5px;">
                        ${stats.wins}W / ${stats.losses}L
                    </div>
                </div>
                <div class="backtest-stat-card">
                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">TOTAL TRADES</div>
                    <div class="backtest-stat-value">${stats.totalTrades}</div>
                    <div style="font-size: 14px; margin-top: 5px;">
                        ${(stats.totalTrades / backtestData.config.period).toFixed(1)}/dia
                    </div>
                </div>
            `;
            
            document.getElementById('backtest-stats').innerHTML = statsHtml;
            
            console.log('🎨 Procurando canvas...');
            const canvas = document.getElementById('equity-chart');
            console.log('Canvas element:', canvas);
            
            const ctx = canvas ? canvas.getContext('2d') : null;
            
            if (!ctx) {
                console.error('❌ Contexto do canvas não encontrado!');
                console.error('Canvas element:', canvas);
                return;
            }
            
            console.log('🎨 Contexto do canvas OK, criando gráfico...');
            
            // Verificar se Chart.js está carregado
            if (typeof Chart === 'undefined') {
                console.error('Chart.js não está carregado');
                return;
            }
            
            // Limpar canvas completamente
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            if (backtestData.chart) {
                backtestData.chart.destroy();
                backtestData.chart = null;
            }
            
            // Tentar criar gráfico simples primeiro
            try {
                backtestData.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates.map(d => {
                            const date = new Date(d);
                            return `Dia ${date.getDate()}`;
                        }),
                        datasets: [{
                            label: 'Capital (USD)',
                            data: equityHistory,
                            borderColor: equityHistory[equityHistory.length - 1] >= backtestData.config.capital ? '#02c076' : '#f84960',
                            backgroundColor: equityHistory[equityHistory.length - 1] >= backtestData.config.capital ? 
                                'rgba(2, 192, 118, 0.1)' : 'rgba(248, 73, 96, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                backgroundColor: 'rgba(30, 35, 41, 0.95)',
                                titleColor: '#f0b90b',
                                bodyColor: '#eaecef',
                                callbacks: {
                                    label: function(context) {
                                        return '$' + context.parsed.y.toFixed(2);
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: { color: 'rgba(255, 255, 255, 0.05)' },
                                ticks: { 
                                    color: '#848e9c',
                                    maxTicksLimit: 10
                                }
                            },
                            y: {
                                grid: { color: 'rgba(255, 255, 255, 0.05)' },
                                ticks: {
                                    color: '#848e9c',
                                    callback: function(value) {
                                        return '$' + value.toFixed(0);
                                    }
                                }
                            }
                        }
                    }
                });
                console.log('✅ Gráfico criado com sucesso');
            } catch (chartError) {
                console.error('❌ Erro ao criar gráfico:', chartError);
            }
        }

        
        window.onload = function() {
            console.log('🚀 Sistema V2.0 inicializando...');
            console.log('🔍 Verificando elementos DOM...');
            
            // Expor ANALYSIS_CONFIG globalmente para acesso aos pesos
            if (typeof window.MarketAnalysisEngine !== 'undefined' && window.MarketAnalysisEngine.getConfig) {
                window.ANALYSIS_CONFIG = window.MarketAnalysisEngine.getConfig();
            }
            
            // Verificar se elementos existem
            const backtestModal = document.getElementById('backtest-modal');
            const equityChart = document.getElementById('equity-chart');
            const backtestBtn = document.querySelector('[onclick*="openBacktestModal"]');
            
            console.log('Elementos encontrados:', {
                backtestModal: !!backtestModal,
                equityChart: !!equityChart,
                backtestBtn: !!backtestBtn
            });
            
            // Aguardar bibliotecas carregarem
            let retries = 0;
            const maxRetries = 10;
            
            function checkLibraries() {
                console.log(`Verificando bibliotecas (tentativa ${retries + 1}/${maxRetries})...`);
                
                if (typeof axios !== 'undefined' && typeof window.MarketAnalysisEngine !== 'undefined' && typeof window.DecisionEvaluator !== 'undefined') {
                    console.log('✅ Todas as bibliotecas carregadas!');
                    console.log('Bibliotecas disponíveis:', {
                        axios: typeof axios,
                        MarketAnalysisEngine: typeof window.MarketAnalysisEngine,
                        analyzeMarket: typeof window.MarketAnalysisEngine?.analyzeMarket,
                        DecisionEvaluator: typeof window.DecisionEvaluator,
                        recordDecision: typeof window.DecisionEvaluator?.recordDecision
                    });
                    
                    initializeApp();
                } else {
                    console.warn('⚠️ Bibliotecas ainda não carregadas:', {
                        axios: typeof axios,
                        MarketAnalysisEngine: typeof window.MarketAnalysisEngine,
                        DecisionEvaluator: typeof window.DecisionEvaluator
                    });
                    
                    retries++;
                    if (retries < maxRetries) {
                        setTimeout(checkLibraries, 500);
                    } else {
                        console.error('❌ Falha ao carregar bibliotecas após', maxRetries, 'tentativas');
                        document.getElementById('result').innerHTML = `
                            <div style="text-align: center; padding: 60px 20px; color: var(--red);">
                                <div style="font-size: 48px; margin-bottom: 20px;">⚠️</div>
                                <div style="font-size: 20px; font-weight: bold; margin-bottom: 10px;">Erro ao Carregar Sistema</div>
                                <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 20px;">
                                    O sistema de análise não foi carregado corretamente.<br>
                                    Por favor, recarregue a página.
                                </div>
                                <button onclick="location.reload()" style="
                                    padding: 12px 24px;
                                    background: var(--accent);
                                    color: var(--bg-dark);
                                    border: none;
                                    border-radius: 8px;
                                    font-weight: bold;
                                    cursor: pointer;
                                ">🔄 Recarregar Página</button>
                            </div>
                        `;
                    }
                }
            }
            
            function initializeApp() {
                // Inicializar valor do Score Mínimo no input
                document.getElementById('minSignalStrength').value = config.minSignalStrength;
                updateMinSignalStrength(config.minSignalStrength);
                
                // Configurar event listeners
                document.getElementById('soundNotifications').addEventListener('change', (e) => {
                    config.soundNotifications = e.target.checked;
                });
                
                document.getElementById('visualNotifications').addEventListener('change', (e) => {
                    config.visualNotifications = e.target.checked;
                });
                
                document.getElementById('trendFilter').addEventListener('change', (e) => {
                    config.trendFilter = e.target.checked;
                    showNotification(
                        'Filtro de Tendência',
                        e.target.checked ? 'Ativado - Sinais filtrados por tendência' : 'Desativado',
                        'info',
                        3000
                    );
                });
                
                document.getElementById('divergenceDetection').addEventListener('change', (e) => {
                    config.divergenceDetection = e.target.checked;
                    showNotification(
                        'Detecção de Divergências',
                        e.target.checked ? 'Ativada - Buscando divergências RSI/Preço' : 'Desativada',
                        'info',
                        3000
                    );
                });
                
                document.getElementById('whaleTracking').addEventListener('change', (e) => {
                    config.whaleTracking = e.target.checked;
                    if (e.target.checked) {
                        initWhaleTracking();
                    } else if (state.wsOrderbook) {
                        state.wsOrderbook.close();
                    }
                    showNotification(
                        'Rastreio de Baleias',
                        e.target.checked ? 'Ativado - Monitorando ordens grandes' : 'Desativado',
                        'info',
                        3000
                    );
                });
                
                document.getElementById('autoBackup').addEventListener('change', (e) => {
                    config.autoBackup = e.target.checked;
                    showNotification(
                        'Auto-Backup',
                        e.target.checked ? 'Ativado - Histórico será salvo automaticamente' : 'Desativado',
                        'info',
                        3000
                    );
                });
                
                document.getElementById('tradingMode').addEventListener('change', (e) => {
                    config.tradingMode = e.target.value;
                    const modes = {
                        aggressive: 'Agressivo - Mais sinais, menos filtros',
                        balanced: 'Balanceado - Equilíbrio entre sinais e precisão',
                        conservative: 'Conservador - Menos sinais, mais seletivo'
                    };
                    showNotification(
                        `Modo ${e.target.value}`,
                        modes[e.target.value],
                        'info',
                        3000
                    );
                });
                
                // Iniciar relógio
                setInterval(updateBrasiliaTime, 1000);
                updateBrasiliaTime();
                
                // CORREÇÃO #2: Carregar priceTracker do localStorage
                loadPriceTracker();
                console.log('✅ priceTracker carregado:', Object.keys(state.priceTracker).length, 'trades rastreados');
                
                // 🧠 Carregar Sistema Adaptativo
                loadAdaptiveSystem();
                console.log('🧠 Sistema Adaptativo carregado');
                
                // Iniciar sistema
                changeCrypto(document.getElementById('cryptoSelect').value);
                console.log('✅ tradeHistory carregado:', {
                    '1m': state.tradeHistory['1m']?.length || 0,
                    '5m': state.tradeHistory['5m']?.length || 0,
                    '15m': state.tradeHistory['15m']?.length || 0,
                    '1h': state.tradeHistory['1h']?.length || 0
                });
                
                // Inicializar descrição do modo de trading
                updateTradingModeDescription('balanced');
                
                // Configurar intervalo
                intervalId = setInterval(performAnalysis, config.refreshInterval);
                
                showNotification('Sistema V2.0 Carregado', 'Análise otimizada iniciada com sucesso!', 'success', 4000);
            }
            
            // Iniciar verificação
            checkLibraries();
        };
        
        window.onbeforeunload = function() {
            // Salvar estado antes de fechar
            if (config.autoBackup) {
                Object.keys(state.tradeHistory).forEach(tf => {
                    saveToLocalStorage(`tradeHistory_${config.symbol}`, state.tradeHistory);
                });
            }
        };
    </script>

    <!-- MODAL DE BACKTESTING -->
    <div id="backtest-modal" class="backtest-modal">
        <div class="backtest-content">
            <div class="backtest-header">
                <div class="backtest-title">📊 Backtesting - <span id="backtest-timeframe-display"></span></div>
                <span class="backtest-close" onclick="closeBacktestModal()">&times;</span>
            </div>
            
            <div class="backtest-config">
                <div class="backtest-config-item">
                    <label>📅 Período</label>
                    <select id="backtest-period">
                        <option value="7">Últimos 7 dias</option>
                        <option value="14">Últimos 14 dias</option>
                        <option value="30">Últimos 30 dias</option>
                    </select>
                </div>
                <div class="backtest-config-item">
                    <label>💰 Capital Inicial</label>
                    <input type="number" id="backtest-capital" value="10000" min="100">
                </div>
                <div class="backtest-config-item">
                    <label>⚡ Alavancagem</label>
                    <select id="backtest-leverage">
                        <option value="1">1x</option>
                        <option value="5">5x</option>
                        <option value="10" selected>10x</option>
                        <option value="20">20x</option>
                        <option value="50">50x</option>
                        <option value="100">100x</option>
                    </select>
                </div>
            </div>
            
            <button class="backtest-btn backtest-btn-run" onclick="runBacktest()" style="width: 100%; margin-bottom: 30px;">
                🚀 Executar Backtest
            </button>
            
            <div id="backtest-loading" class="backtest-loading" style="display: none;">
                <div class="loading-spinner"></div>
                <div>Simulando trades históricos...</div>
            </div>
            
            <div id="backtest-results" class="backtest-results">
                <div class="backtest-stats" id="backtest-stats"></div>
                <div class="backtest-chart-container">
                    <canvas id="equity-chart"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // ============================================
        // SYSTEMSTATE DEBUG MONITOR
        // ============================================
        
        function refreshSystemState() {
            if (!window.SystemState) {
                console.warn('SystemState não carregado');
                return;
            }

            const snapshot = SystemState.getSnapshot();
            const m = snapshot.metrics;
            
            // Debug: mostrar no console também
            if (snapshot.windowSize === 0) {
                console.log('⚠️ SystemState: Nenhuma decisão avaliada ainda. Aguardando evaluation.js avaliar decisões após horizonte mínimo.');
            }
            
            let output = '';
            output += `[${new Date().toLocaleTimeString()}] SystemState Snapshot\n`;
            output += `─────────────────────────────────────────────────\n`;
            output += `window_size: ${snapshot.windowSize}/${snapshot.maxWindowSize}\n`;
            output += `accuracy: ${m.totalDecisions > 0 ? m.recentAccuracy.toFixed(1) : 'N/A'}%\n`;
            output += `win_rate: ${m.totalDecisions > 0 ? m.recentWinRate.toFixed(1) : 'N/A'}%\n`;
            output += `avg_confidence: ${m.totalDecisions > 0 ? m.avgConfidence.toFixed(1) : 'N/A'}\n`;
            output += `consecutive_errors: ${m.consecutiveErrors}\n`;
            output += `max_consecutive_errors: ${m.maxConsecutiveErrors}\n`;
            output += `distribution: BUY=${m.buyRatio.toFixed(0)}% SELL=${m.sellRatio.toFixed(0)}% NEUTRAL=${m.neutralRatio.toFixed(0)}%\n`;
            
            if (snapshot.recentDecisions && snapshot.recentDecisions.length > 0) {
                output += `\nLast ${snapshot.recentDecisions.length} decisions:\n`;
                snapshot.recentDecisions.reverse().forEach((d, i) => {
                    const result = d.success ? 'OK' : 'FAIL';
                    const ret = d.return >= 0 ? `+${d.return.toFixed(2)}` : d.return.toFixed(2);
                    output += `  ${i+1}. ${d.direction.padEnd(7)} ${d.timeframe} ${result.padEnd(4)} ${ret}% conf=${d.confidence.toFixed(0)}\n`;
                });
            } else {
                output += `\n[Aguardando decisões serem avaliadas...]\n`;
                output += `Horizonte mínimo: 1m=3min, 5m=15min, 15m=45min, 1h=3h\n`;
            }

            document.getElementById('systemstate-debug').textContent = output;
        }

        // Atualizar a cada 5 segundos
        setInterval(refreshSystemState, 5000);
        setTimeout(refreshSystemState, 2000);
    </script>

    <!-- SystemState - Monitor de Estado (Somente Leitura) -->
    <script src="systemState.js"></script>
</body>
</html>
